/*
 *  Multi2Sim
 *  Copyright (C) 2012  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */


#include <arch/x86/emu/context.h>
#include <arch/x86/emu/emu.h>
#include <arch/x86/emu/regs.h>
#include <arch/southern-islands/asm/fetch-shader.h>
#include <arch/southern-islands/asm/input.h>
#include <arch/southern-islands/asm/opengl-bin-file.h>
#include <arch/southern-islands/emu/ndrange.h>
#include <arch/southern-islands/emu/sx.h> 
#include <arch/southern-islands/timing/gpu.h>
#include <lib/mhandle/mhandle.h>
#include <lib/util/debug.h>
#include <lib/util/list.h>
#include <lib/util/misc.h>
#include <mem-system/memory.h>
#include <mem-system/mmu.h>

#include "opengl.h"
#include "si-pa.h"
#include "si-program.h"
#include "si-shader.h"
#include "si-sc.h"

/* Debug */
int opengl_debug_category;

#define SI_DRIVER_MAX_WORK_GROUP_BUFFER_SIZE 16

/* Error messages */
/*
static char *opengl_err_not_impl =
	"\tThe OpenGL interface is implemented in library 'm2s-opengl.so' as a set of\n"
	"\tsystem calls, intercepted by Multi2Sim and emulated in 'opengl.c'.\n"
	"\tHowever, only a subset of this interface is currently implemented in the simulator.\n"
	"\tTo request the implementation of a specific OpenGL call, please email\n"
	"\t'development@multi2sim.org'.\n";
*/

static char *opengl_version_code =
	"\tAn invalid function code was generated by your application in a OpenGL system\n"
	"\tcall. Probably, this means that your application is using an incompatible\n"
	"\tversion of the Multi2Sim OpenGL runtime library ('libm2s-opengl'). Please\n"
	"\trecompile your application and try again.\n";



/* List of OpenGL Runtime calls */
enum opengl_abi_call_t
{
	opengl_abi_call_invalid = 0,
#define OPENGL_ABI_CALL(name, code) opengl_abi_##name = code,
#include "opengl.dat"
#undef OPENGL_ABI_CALL
	opengl_abi_call_count
};


/* List of OpenGL ABI call names */
char *opengl_abi_call_name[opengl_abi_call_count + 1] =
{
	NULL,
#define OPENGL_ABI_CALL(name, code) #name,
#include "opengl.dat"
#undef OPENGL_ABI_CALL
	NULL
};

/* Forward declarations of OpenGL Runtime functions */
#define OPENGL_ABI_CALL(name, code) \
	static int opengl_abi_##name##_impl(X86Context *ctx);
#include "opengl.dat"
#undef OPENGL_ABI_CALL


/* List of OpenGL Runtime functions */
typedef int (*opengl_abi_call_t)(X86Context *ctx);
static opengl_abi_call_t opengl_abi_call_table[opengl_abi_call_count + 1] =
{
	NULL,
#define OPENGL_ABI_CALL(name, code) opengl_abi_##name##_impl,
#include "opengl.dat"
#undef OPENGL_ABI_CALL
	NULL
};


#define __NOT_IMPL__  fatal("%s: not implemented.\n%s", \
	__FUNCTION__, opengl_err_not_impl);



/*
 * Class 'OpenglDriver'
 */

void OpenglDriverCreate(OpenglDriver *self, X86Emu *x86_emu, SIEmu *si_emu)
{
	/* Parent */
	DriverCreate(asDriver(self), x86_emu);

	/* Initialize */
	self->si_emu = si_emu;

	/* Assign driver to host emulator */
	x86_emu->opengl_driver = self;
	si_emu->opengl_driver = self;

	/* List of SI OpenGL programs */
	self->opengl_si_program_list = list_create();
	list_add(self->opengl_si_program_list, NULL);

	/* List of SI OpenGL shaders */
	self->opengl_si_shader_list = list_create();
	list_add(self->opengl_si_shader_list, NULL);

	/* List of SI NDRanges */
	self->opengl_si_ndrange_list = list_create();

	/* Viewport */
	self->opengl_si_vwpt = opengl_pa_viewport_create();

	/* Assign driver to host emulator */
	x86_emu->opengl_driver = self;
}


void OpenglDriverDestroy(OpenglDriver *self)
{
	int index;
	struct list_t *program_list;
	struct list_t *shader_list;
	struct opengl_si_program_t *program;
	struct opengl_si_shader_t *shdr;

	program_list = self->opengl_si_program_list;
	shader_list = self->opengl_si_shader_list;

	/* Free list of Southern Islands programs */
	LIST_FOR_EACH(program_list, index)
	{
		program = list_get(program_list, index);
		if (program)
			opengl_si_program_free(program);
	}
	list_free(program_list);

	/* Free list of Southern Islands shaders */
	LIST_FOR_EACH(shader_list, index)
	{
		shdr = list_get(shader_list, index);
		if (shdr)
			opengl_si_shader_free(shdr);
	}
	list_free(shader_list);

	/* Free list of Southern Islands nd-ranges*/
	assert(!list_count(self->opengl_si_ndrange_list));
	list_free(self->opengl_si_ndrange_list);

	/* Free viewport */
	opengl_pa_viewport_free(self->opengl_si_vwpt);

}

/* This function is called when all work groups from an ND-Range have
 * been scheduled (i.e., ndrange->waiting_work_groups is empty) */
void OpenglDriverRequestWork(OpenglDriver *self, SINDRange *ndrange)
{
	X86Emu *emu = asDriver(self)->emu;

	opengl_debug("%s: nd-range %d waiting queue is empty\n", 
		__FUNCTION__, ndrange->id);

	X86EmuProcessEventsSchedule(emu);
}


/* This function is called when all work groups from an ND-Range have
 * been scheduled and completed (i.e., ndrange->waiting_work_groups and 
 * ndrange->running_work_groups are both empty) */
void OpenglDriverNDRangeComplete(OpenglDriver *self, SINDRange *ndrange)
{
	X86Emu *emu = asDriver(self)->emu;

	opengl_debug("%s: nd-range %d complete\n", 
		__FUNCTION__, ndrange->id);

	X86EmuProcessEventsSchedule(emu);
}

/*
 * Public
 */

int OpenglDriverCall(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;

	/* Variables */
	int code;
	int ret;

	/* Function code */
	code = regs->ebx;
	if (code <= opengl_abi_call_invalid || code >= opengl_abi_call_count)
		fatal("%s: invalid OpenGL function (code %d).\n%s",
			__FUNCTION__, code, opengl_version_code);

	/* Debug */
	opengl_debug("OpenGL runtime call '%s' (code %d)\n",
		opengl_abi_call_name[code], code);

	/* Call OPENGL function */
	assert(opengl_abi_call_table[code]);
	ret = opengl_abi_call_table[code](ctx);

	/* Return value */
	return ret;
}


/*
 * OpenGL ABI call #1 - init
 *
 * Returns the version of the OpenGL driver.
 *
 * @param struct opengl_version_t *version
 *
 * 	The driver returns its version information in this argument, with a
 * 	data structure formed of two integer fields:
 *
 * 	struct opengl_version_t
 * 	{
 * 		int major;
 * 		int minor;
 * 	};
 *
 * @return
 *	The function always returns 0.
 */

/* NOTE: when modifying the values of these two macros, the same values should
 * be reflected in 'runtime/opengl/context.c'. */
#define OPENGL_VERSION_MAJOR  1
#define OPENGL_VERSION_MINOR  1000

struct opengl_version_t
{
	int major;
	int minor;
};

static int opengl_abi_init_impl(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int version_ptr;
	struct opengl_version_t version;

	/* Arguments */
	version_ptr = regs->ecx;
	opengl_debug("\tversion_ptr=0x%x\n", version_ptr);

	/* Return version */
	assert(sizeof(struct opengl_version_t) == 8);
	version.major = OPENGL_VERSION_MAJOR;
	version.minor = OPENGL_VERSION_MINOR;
	mem_write(mem, version_ptr, sizeof version, &version);
	opengl_debug("\tMulti2Sim OpenGL implementation in host: v. %d.%d.\n",
		OPENGL_VERSION_MAJOR, OPENGL_VERSION_MINOR);
	opengl_debug("\tMulti2Sim OpenGL Runtime in guest: v. %d.%d.\n",
		version.major, version.minor);

	/* Return success */
	return 0;
}

/*
 * OpenGL ABI call #2 - done
 *
 * Finialize, free all created objects 
 *
 * @return
 *	The function always returns 0.
 */

static int opengl_abi_done_impl(X86Context *ctx)
{
	/* Return success */
	return 0;
}

/*
 * OpenGL ABI call #3 - si_mem_alloc
 *
 * Allocates memory in the Southern Islands device.
 *
 * @param unsigned int size
 *
 * 	Number of bytes to allocate.
 *
 * @return void *
 *
 *	The function returns a pointer in the device memory space. This pointer
 *	should not be dereferenced in the runtime, but instead passed to other
 *	ABI calls taking device pointers as input arguments.
 */

static int opengl_abi_si_mem_alloc_impl(X86Context *ctx)
{
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;
	SIEmu *si_emu = driver->si_emu;
	SIGpu *si_gpu = driver->si_gpu;

	struct x86_regs_t *regs = ctx->regs;

	unsigned int size;
	unsigned int device_ptr;

	/* Arguments */
	size = regs->ecx;

	if (si_gpu)
	{
		/* Allocate starting from nearest page boundary */
		if (si_emu->video_mem_top % si_gpu->mmu->page_mask)
		{
			si_emu->video_mem_top += si_gpu->mmu->page_size -
				(si_emu->video_mem_top & 
				 si_gpu->mmu->page_mask);
		}

	}

	/* Map new pages */
	mem_map(si_emu->video_mem, si_emu->video_mem_top, size,
		mem_access_read | mem_access_write);

	/* Virtual address of memory object */
	device_ptr = si_emu->video_mem_top;
	opengl_debug("\t%d bytes of device memory allocated at 0x%x\n",
			size, device_ptr);

	/* For now, memory allocation in device memory is done by just 
	 * incrementing a pointer to the top of the global memory space. 
	 * Since memory deallocation is not implemented, "holes" in the 
	 * memory space are not considered. */
	si_emu->video_mem_top += size;

	/* Return device pointer */
	return device_ptr;
}




/*
 * OpenGL ABI call #4 - si_mem_read
 *
 * Read memory from Southern Islands device into host memory space.
 *
 * @param void *host_ptr
 *
 * 	Destination pointer in host memory space.
 *
 * @param void *device_ptr
 *
 * 	Source pointer in device memory space.
 *
 * @param unsigned int size
 *
 * 	Number of bytes to read.
 *
 * @return void
 *
 *	The function does not have any return value.
 */

static int opengl_abi_si_mem_read_impl(X86Context *ctx)
{
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;
	SIEmu *si_emu = driver->si_emu;

	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int host_ptr;
	unsigned int device_ptr;
	unsigned int size;

	void *buf;

	/* Arguments */
	host_ptr = regs->ecx;
	device_ptr = regs->edx;
	size = regs->esi;
	opengl_debug("\thost_ptr = 0x%x, device_ptr = 0x%x, size = %d bytes\n",
			host_ptr, device_ptr, size);

	/* Check memory range */
	if (device_ptr + size > si_emu->video_mem_top)
		fatal("%s: accessing device memory not allocated",
				__FUNCTION__);

	/* Read memory from device to host */
	buf = xmalloc(size);
	mem_read(si_emu->video_mem, device_ptr, size, buf);
	mem_write(mem, host_ptr, size, buf);
	free(buf);

	/* Return */
	return 0;
}




/*
 * OpenGL ABI call #5 - si_mem_write
 *
 * Write memory from host into Southern Islands device.
 *
 * @param void *device_ptr
 *
 * 	Destination pointer in device memory.
 *
 * @param void *host_ptr
 *
 * 	Source pointer in host memory.
 *
 * @param unsigned int size
 *
 * 	Number of bytes to read.
 *
 * @return void
 *
 *	The function does not have any return value.
 */

static int opengl_abi_si_mem_write_impl(X86Context *ctx)
{
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;
	SIEmu *si_emu = driver->si_emu;

	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int device_ptr;
	unsigned int host_ptr;
	unsigned int size;

	void *buf;

	/* Arguments */
	device_ptr = regs->ecx;
	host_ptr = regs->edx;
	size = regs->esi;
	opengl_debug("\tdevice_ptr = 0x%x, host_ptr = 0x%x, size = %d bytes\n",
			device_ptr, host_ptr, size);

	/* Check memory range */
	if (device_ptr + size > si_emu->video_mem_top)
		fatal("%s: accessing device memory not allocated",
				__FUNCTION__);

	/* Write memory from host to device */
	buf = xmalloc(size);
	mem_read(mem, host_ptr, size, buf);
	mem_write(si_emu->video_mem, device_ptr, size, buf);
	free(buf);

	/* Return */
	return 0;
}




/*
 * OpenGL ABI call #6 - si_mem_copy
 *
 * Copy memory across two different regions of the Southern Islands device
 * memory space.
 *
 * @param void *dest_ptr
 *
 * 	Destination pointer in device memory.
 *
 * @param void *src_ptr
 *
 * 	Source pointer in device memory.
 *
 * @param unsigned int size
 *
 * 	Number of bytes to read.
 *
 * @return void
 *
 *	The function does not have any return value.
 */

static int opengl_abi_si_mem_copy_impl(X86Context *ctx)
{
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;
	SIEmu *si_emu = driver->si_emu;

	struct x86_regs_t *regs = ctx->regs;

	unsigned int dest_ptr;
	unsigned int src_ptr;
	unsigned int size;

	void *buf;

	/* Arguments */
	dest_ptr = regs->ecx;
	src_ptr = regs->edx;
	size = regs->esi;
	opengl_debug("\tdest_ptr = 0x%x, src_ptr = 0x%x, size = %d bytes\n",
			dest_ptr, src_ptr, size);

	/* Check memory range */
	if (src_ptr + size > si_emu->video_mem_top ||
			dest_ptr + size > si_emu->video_mem_top)
		fatal("%s: accessing device memory not allocated",
				__FUNCTION__);

	/* Write memory from host to device */
	buf = xmalloc(size);
	mem_read(si_emu->video_mem, src_ptr, size, buf);
	mem_write(si_emu->video_mem, dest_ptr, size, buf);
	free(buf);

	/* Return */
	return 0;
}


/*
 * OpenGL ABI call #7 - si_mem_free
 *
 * Deallocated memory in Southern Islands global memory scope.
 *
 * @param unsigned int device_ptr
 *
 * 	Memory address in device global memory returned previously by a call to
 *	'si_mem_alloc'.
 *
 * @return void
 *
 *	No value is returned.
 */

static int opengl_abi_si_mem_free_impl(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;

	unsigned int device_ptr;

	/* Arguments */
	device_ptr = regs->ecx;
	opengl_debug("\tdevice_ptr = 0x%x\n", device_ptr);

	/* For now, this call is ignored. No deallocation of global memory can
	 * happen. */

	/* Return device pointer */
	return device_ptr;
}



/*
 * OpenGL ABI call #8 - si_program_create
 *
 * Create a Southern Islands program object 
 *
 * @return int
 *
 *	
 	No value is returned.
 */

static int opengl_abi_si_program_create_impl(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;

	struct opengl_si_program_t *program;
	unsigned int program_id;

	/* Arguments */
	program_id = regs->ecx;

	/* Create program */
	program = opengl_si_program_create(driver, program_id);

	opengl_debug("\tnew program_id = %d\n", program->id);

	/* Return program ID */
	return 0;
}



/*
 * OpenGL ABI call #9 - si_program_free
 *
 * Free a Southern Islands program object 
 *
 * @return int
 *
 *	No value is returned.
 */

static int opengl_abi_si_program_free_impl(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;

	struct opengl_si_program_t *program;
	unsigned int program_id;

	/* Arguments */
	program_id = regs->ecx;

	/* Create program */
	program = list_get(driver->opengl_si_program_list ,program_id);
	opengl_debug("\tfree program ID = %d\n", program->id);

	/* Free program object */
	opengl_si_program_free(program);

	/* Return */
	return 0;
}



/*
 * OpenGL ABI call #10 - si_program_set_binary
 *
 * Associate a binary to a Southern Islands program. Also setup associated shaders. 
 *
 * @param int program_id
 *
 * 	Program ID, as returned by a previous ABI call to 'si_program_create'.
 *
 * @param void *buf
 *
 * 	Pointer to the memory space where the program binary can be found.
 *
 * @param unsigned int size
 *
 * 	Size of the program binary
 *
 * @return void
 *
 *	No return value.
 */

static int opengl_abi_si_program_set_binary_impl(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;

	struct opengl_si_program_t *program;
	int program_id;

	unsigned int bin_ptr;
	unsigned int bin_size;
	void *buf;

	/* Arguments */
	program_id = regs->ecx;
	bin_ptr = regs->edx;
	bin_size = regs->esi;
	opengl_debug("\tprogram_id = %d, bin_ptr = 0x%x, size = %u\n",
			program_id, bin_ptr, bin_size);

	/* Get program */
	program = list_get(driver->opengl_si_program_list, program_id);
	if (!program)
		fatal("%s: invalid program ID (%d)",
				__FUNCTION__, program_id);

	/* Set the binary */
	buf = xmalloc(bin_size);
	mem_read(ctx->mem, bin_ptr, bin_size, buf);
	opengl_si_program_set_binary(program, buf, bin_size);
	free(buf);
	
	/* No return value */
	return 0;
}



/*
 * OpenGL ABI call #11 - si_shader_create
 *
 * Create a Southern Islands shader object and return a unique identifier
 * for it.
 *
 * @return void
 *
 *	No return value.
 */

static int opengl_abi_si_shader_create_impl(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;

	struct opengl_si_program_t *program;
	unsigned int program_id;
	unsigned int shader_id;
	unsigned int shader_type;

	/* Arguments */
	program_id = regs->ecx;
	shader_id = regs->edx;
	shader_type = regs->esi;
	opengl_debug("\tprogram_id = %d, shader_id = %d, type = %x\n", program_id, shader_id, shader_type);

	/* Create a shader object and initialize it with shader binaries in program object */
	program = list_get(driver->opengl_si_program_list, program_id);
	if (program)
		opengl_si_shader_create(driver->opengl_si_shader_list, program, shader_id, shader_type);	

	/* Return */	
	return 0;
}



/*
 * OpenGL ABI call #12 - si_shader_free
 *
 * Free a Southern Islands shader object 
 *
 */

static int opengl_abi_si_shader_free_impl(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;

	struct opengl_si_shader_t *shdr;
	unsigned int shader_id;

	/* Arguments */
	shader_id = regs->ecx;
	opengl_debug("\tshader_id=%d\n", shader_id);

	/* Get and free */
	shdr = list_get(driver->opengl_si_shader_list, shader_id);
	if (shdr)
		opengl_si_shader_free(shdr);

	return 0;
}

/*
 * OpenGL ABI call #13 - si_shader_set_input
 *
 * Set up the expected input in a shader 
 *
 */

static int opengl_abi_si_shader_set_input_impl(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;
	struct mem_t *mem = ctx->mem;

	struct opengl_si_shader_t *shdr;
	struct list_t *input_list;
	SIInput *input = NULL, *tmp;
	int i;

	unsigned int args[6];
	unsigned int shader_id;
	unsigned int device_ptr;
	unsigned int num_elems;
	unsigned int data_type;
	unsigned int size;
	unsigned int index;

	/* Arguments */
	mem_read(mem, regs->ecx, 6 * sizeof(unsigned int), args);
	shader_id = args[0];
	device_ptr = args[1];
	num_elems = args[2];
	data_type = args[3];
	size = args[4];
	index = args[5];

	opengl_debug("\tshader_id = %d, device_ptr = 0x%x, num_elems = %d, type = %d, size = %d, index = %d\n",
		shader_id, device_ptr, num_elems, data_type, size, index);

	/* Shader has the indices of vertex attribute array in its encoding dictionary */
	shdr = list_get(driver->opengl_si_shader_list, shader_id);
	input_list = shdr->input_list;
	LIST_FOR_EACH(input_list, i)
	{
		tmp = list_get(input_list, i);
		if (tmp->usage_index == index)
			input = tmp;
	}

	if (!input)
		panic("Vertex attribute array at index %d is not needed\n", index);
	else
	{
		input->set = 1;
		input->num_elems = num_elems;
		input->type = SIInputGetType(data_type);
		input->device_ptr = device_ptr;
		input->size = size;
	}

	return 0;
}

/*
 * OpenGL ABI call #14- si_ndrange_create
 *
 * Create and initialize an ND-Range for the supplied shader.
 *
 * @param int shader_id
 *
 * 	Shader ID, assigned in OpenGL runtime and bound to certain OpenGL program
 *
 * @param int work_dim
 *
 * 	Number of work dimensions. This is an integer number between 1 and 3,
 * 	which determines the number of elements of the following arrays.
 *
 * @param unsigned int *global_offset
 *
 *	Array of 'work_dim' integers containing global offsets.
 *
 * @param unsigned int *global_size
 *
 *	Array of 'work_dim' integers containing the ND-Range global size in each
 *	dimension.
 *
 * @param unsigned int *local_size
 *
 *	Array of 'work_dim' integers containing the local size in each
 *	dimension.
 *
 * @return int
 *
 *	Unique NDRange ID.
 */

static int opengl_abi_si_ndrange_create_impl(X86Context *ctx)
{
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;
	SIEmu *si_emu = driver->si_emu;
	SIGpu *si_gpu = driver->si_gpu;

	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	struct elf_buffer_t *elf_buffer;
	struct opengl_si_shader_t *shader;
	struct opengl_si_enc_dict_vertex_shader_t *vs;
	struct opengl_si_enc_dict_pixel_shader_t *ps;
	struct si_fetch_shader_t *fs;
	struct SIBinaryUserElement *user_elements;
	SINDRange *ndrange;

	int i;
	int shader_id;
	int user_element_count;
	int work_dim;

	unsigned int global_offset_ptr;
	unsigned int global_size_ptr;
	unsigned int local_size_ptr;

	unsigned int global_offset[3];
	unsigned int global_size[3];
	unsigned int local_size[3];

	/* Arguments */
	shader_id = regs->ecx;
	work_dim = regs->edx;
	global_offset_ptr = regs->esi;
	global_size_ptr = regs->edi;
	local_size_ptr = regs->ebp;
	opengl_debug("\tshader_id = %d, work_dim = %d\n", shader_id, work_dim);
	opengl_debug("\tglobal_offset_ptr = 0x%x, global_size_ptr = 0x%x, "
		"local_size_ptr = 0x%x\n", global_offset_ptr, global_size_ptr, 
		local_size_ptr);
	
	/* Debug */
	assert(IN_RANGE(work_dim, 1, 3));
	mem_read(mem, global_offset_ptr, work_dim * 4, global_offset);
	mem_read(mem, global_size_ptr, work_dim * 4, global_size);
	mem_read(mem, local_size_ptr, work_dim * 4, local_size);
	for (i = 0; i < work_dim; i++)
		opengl_debug("\tglobal_offset[%d] = %u\n", i, global_offset[i]);
	for (i = 0; i < work_dim; i++)
		opengl_debug("\tglobal_size[%d] = %u\n", i, global_size[i]);
	for (i = 0; i < work_dim; i++)
		opengl_debug("\tlocal_size[%d] = %u\n", i, local_size[i]);

	/* Get shader */
	shader = list_get(driver->opengl_si_shader_list, shader_id);
	if (!shader)
		fatal("%s: invalid shader ID (%d)", __FUNCTION__, shader_id);

	/* Create ND-Range */
	ndrange = new(SINDRange, si_emu);
	ndrange->local_mem_top = shader->mem_size_local;

	switch(shader->shader_kind)
	{

	case OPENGL_SI_SHADER_VERTEX:
	{
		/* Some metadata from shader binary */
		vs = (struct opengl_si_enc_dict_vertex_shader_t *)shader->bin->enc_dict;
		ndrange->num_sgpr_used = vs->meta->u32NumSgprs;
		ndrange->num_vgpr_used = vs->meta->u32NumVgprs;
		ndrange->wg_id_sgpr = vs->meta->spiShaderPgmRsrc2Vs.user_sgpr;
		/* Copy user elements from shader to ND-Range */
		user_element_count = vs->meta->u32UserElementCount;
		user_elements = vs->meta->pUserElement;
		ndrange->userElementCount = user_element_count;
		for (i = 0; i < user_element_count; i++)
		{
			ndrange->userElements[i] = user_elements[i];
		}
		/* Setup NDRange stage */
		SINDRangeSetupStage(ndrange, STAGE_VS);
		break;

	}

	case OPENGL_SI_SHADER_PIXEL:
	{
		/* Some metadata from shader binary */
		ps = (struct opengl_si_enc_dict_pixel_shader_t *)shader->bin->enc_dict;
		ndrange->num_sgpr_used = ps->meta->u32NumSgprs;
		ndrange->num_vgpr_used = ps->meta->u32NumVgprs;
		/* Copy user elements from shader to ND-Range */
		user_element_count = ps->meta->u32UserElementCount;
		user_elements = ps->meta->pUserElement;
		ndrange->userElementCount = user_element_count;
		for (i = 0; i < user_element_count; i++)
		{
			ndrange->userElements[i] = user_elements[i];
		}
		/* Setup NDRange stage */
		SINDRangeSetupStage(ndrange, STAGE_PS);
		break;		
	}
	
	default:
		break;
	}

	SINDRangeSetupSize(ndrange, global_size, local_size, work_dim);

	/* Set up instruction memory */
	/* Initialize wavefront instruction buffer and PC */
	elf_buffer = shader->bin->isa;
	if (!elf_buffer->size)
		fatal("%s: cannot load shader code", __FUNCTION__);

	SINDRangeSetupInstMem(ndrange, elf_buffer->ptr, 
		elf_buffer->size, 0);

	/* Create Fetch Shader, Vertex Shader only */
	if (shader->shader_kind == OPENGL_SI_SHADER_VERTEX)
	{
		fs = si_fetch_shader_create(shader);
		SINDRangeSetupFSMem(ndrange, fs->isa, fs->size, 0);
		si_fetch_shader_free(fs);
	}

	if (si_gpu)
		SIGpuMapNDRange(si_gpu, ndrange);

	list_add(driver->opengl_si_ndrange_list, ndrange);
	opengl_debug("\tNDRange #%d insert into NDRange list\n", 
		ndrange->id);

	/* Return NDRange ID */
	return ndrange->id;
}




/*
 * OpenGL ABI call #15 - si_ndrange_get_num_buffer_entries
 *
 * Returns the number of available buffer entries in the waiting 
 * work-group queue.
 *
 * @param unsigned int *host_ptr
 *
 *	Location to be populated with the number of available 
 *	buffer entry slots.
 *
 * @return int
 *
 *	The function always returns 0.
 */


static int opengl_abi_si_ndrange_get_num_buffer_entries_impl(
	X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;
	SIGpu *si_gpu = driver->si_gpu;

	unsigned int host_ptr;

	int available_buffer_entries;

	/* Arguments */
	host_ptr = regs->ecx;

	if (si_gpu)
	{
		available_buffer_entries = 
			SI_DRIVER_MAX_WORK_GROUP_BUFFER_SIZE -
			list_count(si_gpu->waiting_work_groups);
	}
	else
	{
		available_buffer_entries = 
			SI_DRIVER_MAX_WORK_GROUP_BUFFER_SIZE;
	}

	opengl_debug("\tavailable buffer entries = %d\n", 
		available_buffer_entries);

	mem_write(mem, host_ptr, sizeof available_buffer_entries,
		&available_buffer_entries);

	return 0;
}

/*
 * OpenGL ABI call #16 - si_ndrange_send_work_groups
 *
 * Receives a range of work-group IDs to add to the waiting 
 * work-group queue. The x86 context performing this call
 * suspends until the emulator needs more work.
 *
 * @param int work_group_start_id 
 *
 *	The first work-group ID to add to the waiting queue.
 *
 * @param int work_group_count
 *
 *	The number of work groups to add to the waiting queue.
 *
 * @return int
 *
 *	The function always returns 0.
 */

static int opengl_abi_si_ndrange_send_work_groups_can_wakeup(
	X86Context *ctx, void *user_data)
{
	assert(user_data);
	SINDRange *ndrange = (SINDRange *) user_data;

	return !list_count(ndrange->waiting_work_groups);
}

static void opengl_abi_si_ndrange_send_work_groups_wakeup(
	X86Context *ctx, void *user_data)
{
	assert(user_data);
	SINDRange *ndrange = (SINDRange *) user_data;

	assert(!list_count(ndrange->waiting_work_groups));

	return;
}

static int opengl_abi_si_ndrange_send_work_groups_impl(X86Context *ctx)
{
	X86Emu *emu = ctx->emu;
	OpenglDriver *driver = emu->opengl_driver;
	SINDRange *ndrange = NULL, *tmp;
	int index;

	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	int i, j, k;

	unsigned int work_group_start_ptr;
	unsigned int work_group_count_ptr;
	unsigned int work_group_sizes_ptr;
	unsigned int ndrange_id;
	unsigned int work_group_start[3];
	unsigned int work_group_count[3];
	unsigned int work_group_sizes[3];
	unsigned int total_num_groups;

	long work_group_id;

	/* Arguments */
	work_group_start_ptr = regs->ecx;
	work_group_count_ptr = regs->edx;
	work_group_sizes_ptr = regs->esi;
	ndrange_id = regs->edi;

	LIST_FOR_EACH(driver->opengl_si_ndrange_list, index)
	{
		tmp = (SINDRange* )list_get(driver->opengl_si_ndrange_list, index);
		if (tmp->id == ndrange_id)
			ndrange = tmp;
	}
	if (!ndrange)
		fatal("%s: invalid ndrange ID (%d)", __FUNCTION__, ndrange_id);

	opengl_debug("\tndrange %d\n", ndrange->id);

	assert(ndrange);

	mem_read(mem, work_group_start_ptr, 3 * 4, work_group_start);
	mem_read(mem, work_group_count_ptr, 3 * 4, work_group_count);
	mem_read(mem, work_group_sizes_ptr, 3 * 4, work_group_sizes);

	total_num_groups = work_group_count[2] * work_group_count[1] * 
		work_group_count[0];
	assert(total_num_groups <= SI_DRIVER_MAX_WORK_GROUP_BUFFER_SIZE -
		list_count(ndrange->waiting_work_groups));

	opengl_debug("\treceiving %d work groups: (%d,%d,%d) through (%d,%d,%d)\n",
		work_group_count[2] * work_group_count[1] * work_group_count[0],
		work_group_start[0], work_group_start[1], work_group_start[2],
		work_group_start[0] + work_group_count[0] - 1, 
		work_group_start[1] + work_group_count[1] - 1, 
		work_group_start[2] + work_group_count[2] - 1);

	/* Receive work groups (add them to the waiting queue) */
	for (i = work_group_start[2]; i < work_group_start[2] + work_group_count[2]; i++)
	{
		for (j = work_group_start[1]; j < work_group_start[1] + work_group_count[1]; j++)
		{
			for (k = work_group_start[0]; k < work_group_start[0] + work_group_count[0]; k++)
			{
				work_group_id = (i * work_group_sizes[1] * 
					work_group_sizes[0]) + (j * 
					work_group_sizes[0]) + k;

				list_enqueue(ndrange->waiting_work_groups, 
					(void*)work_group_id);
			}
		}
	}

	/* Suspend x86 context until driver needs more work */
	X86ContextSuspend(ctx, 
		opengl_abi_si_ndrange_send_work_groups_can_wakeup, 
		ndrange, opengl_abi_si_ndrange_send_work_groups_wakeup, 
		ndrange);

	return 0;
}

/*
 * OpenGL ABI call #17 - si_ndrange_finish
 *
 * Tells the driver that there are no more work groups to execute
 * from the ND-Range.
 *
 * @return int
 *
 *	The function always returns 0.
 */

static int opengl_abi_si_ndrange_finish_can_wakeup(X86Context *ctx, 
	void *user_data)
{
	assert(user_data);
	SINDRange *ndrange = (SINDRange *) user_data;

	assert(ndrange->last_work_group_sent);
	
	int can_wakeup =
		!list_count(ndrange->waiting_work_groups) &&
		!list_count(ndrange->running_work_groups);

	return can_wakeup;
}

static void opengl_abi_si_ndrange_finish_wakeup(X86Context *ctx, 
	void *user_data)
{
	assert(user_data);

	X86Emu *emu = ctx->emu;
	OpenglDriver *driver = emu->opengl_driver;
	SINDRange *ndrange = (SINDRange *) user_data;

	assert(!list_count(ndrange->waiting_work_groups));
	assert(!list_count(ndrange->running_work_groups));
	assert(ndrange->last_work_group_sent);

	list_remove(driver->opengl_si_ndrange_list, ndrange);

	delete(ndrange);

	return;
}

static int opengl_abi_si_ndrange_finish_impl(X86Context *ctx)
{
	X86Emu *emu = ctx->emu;
	OpenglDriver *driver = emu->opengl_driver;
	struct x86_regs_t *regs = ctx->regs;

	SINDRange *ndrange = NULL, *tmp;
	int index;

	int ndrange_id = regs->ecx;

	LIST_FOR_EACH(driver->opengl_si_ndrange_list, index)
	{
		tmp = (SINDRange* )list_get(driver->opengl_si_ndrange_list, index);
		if (tmp->id == ndrange_id)
			ndrange = tmp;
	}
	if (!ndrange)
		fatal("%s: invalid ndrange ID (%d)", __FUNCTION__, ndrange_id);

	ndrange->last_work_group_sent = 1;
	
	/* If no work-groups are left in the queues, remove the nd-range
	 * from the driver list */
	if (!list_count(ndrange->running_work_groups) && 
		!list_count(ndrange->waiting_work_groups))
	{
		opengl_debug("\tnd-range %d finished\n", ndrange_id);
		list_remove(driver->opengl_si_ndrange_list, ndrange);
		delete(ndrange);
	}
	else
	{
		opengl_debug("\twaiting for nd-range %d to finish (blocking)\n", 
				ndrange_id);
		X86ContextSuspend(ctx, 
			opengl_abi_si_ndrange_finish_can_wakeup, ndrange, 
			opengl_abi_si_ndrange_finish_wakeup, ndrange);
	}

	return 0;
}


/*
 * OpenGL ABI call #18 - si_ndrange_pass_mem_objs
 *
 * @return int
 *
 *	The function always returns 0.
 */

static int opengl_abi_si_ndrange_pass_mem_objs_impl(X86Context *ctx)
{
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;
	SIGpu *si_gpu = driver->si_gpu;
	SINDRange *ndrange = NULL, *tmp;
	struct opengl_si_shader_t *shader;
	struct x86_regs_t *regs = ctx->regs;

	int shader_id;
	int ndrange_id;

	shader_id =  regs->ecx;
	ndrange_id = regs->edx;

	shader = list_get(driver->opengl_si_shader_list, shader_id);

	int index;
	LIST_FOR_EACH(driver->opengl_si_ndrange_list, index)
	{
		tmp = (SINDRange* )list_get(driver->opengl_si_ndrange_list, index);
		if (tmp->id == ndrange_id)
			ndrange = tmp;
	}
	if (!ndrange)
		fatal("%s: invalid ndrange ID (%d)", __FUNCTION__, ndrange_id);

	if (si_gpu)
	{
		opengl_si_shader_create_ndrange_tables(ndrange, 
			si_gpu->mmu); 
		opengl_si_shader_create_ndrange_constant_buffers(
			ndrange, si_gpu->mmu); 
	}
	else
	{
		opengl_si_shader_create_ndrange_tables(ndrange, NULL); 
		opengl_si_shader_create_ndrange_constant_buffers(
			ndrange, NULL); 
	}

	opengl_si_shader_setup_ndrange_constant_buffers(ndrange);
	opengl_si_shader_setup_ndrange_inputs(shader, ndrange);
	opengl_si_shader_debug_ndrange_state(shader, ndrange);

	return 0;
}

/*
 * OpenGL ABI call #19 - si_viewport
 *
 * @return int
 *
 *	The function always returns 0.
 */

static int opengl_abi_si_viewport_impl(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;

	unsigned int x;
	unsigned int y;
	unsigned int width;
	unsigned int height;

	/* Arguments */
	x = regs->ecx;
	y = regs->edx;
	width = regs->esi;
	height = regs->edi;

	/* Debug */
	opengl_debug("\tViewport x = %d, y = %d, width = %d, height = %d\n", 
		x, y, width, height);

	/* Set Viewport */
	opengl_pa_viewport_set(driver->opengl_si_vwpt, x, y, width, height);
	
	/* Return */
	return 0;
}

/*
 * OpenGL ABI call #20 - si_raster
 *
 * @return int
 *
 *	The function always returns 0.
 */

static int opengl_abi_si_raster_impl(X86Context *ctx)
{
	struct x86_regs_t *regs = ctx->regs;	
	X86Emu *x86_emu = ctx->emu;
	OpenglDriver *driver = x86_emu->opengl_driver;
	SIEmu *si_emu = driver->si_emu;
	int i;
	int j;

	unsigned int mode;

	mode = regs->ecx;

	float *pos;
	int pos_idx;
	struct list_t *pos_lst;
	struct list_t *pixel_list;
	struct opengl_sc_pixel_info_t *pixel;
	struct opengl_pa_primitive_t *prmtv;
	struct opengl_pa_triangle_t *triangle;
	
	opengl_debug("\tprimitive mode %d\n", mode);

	/* FIXME: currently triangle only */

	for (pos_idx = 0; pos_idx < SI_POS_COUNT; ++pos_idx)
	{
		pos_lst = si_emu->sx->pos[pos_idx];
		if (list_count(pos_lst))
		{
			/* Start to generate pixel info */
			prmtv = opengl_pa_primitives_create(OPENGL_PA_TRIANGLES, pos_lst, driver->opengl_si_vwpt);
			LIST_FOR_EACH(prmtv->list, i)
			{
				triangle = list_get(prmtv->list, i);

				/* Rasterization */
				pixel_list = opengl_sc_rast_triangle_gen(triangle);
				if (pixel_list)
				{
					LIST_FOR_EACH(pixel_list, j)
					{
						pixel = list_get(pixel_list, j);
						SISXPSInitMetaAdd(si_emu->sx, pixel->brctrc_i, pixel->brctrc_j);
					}
					opengl_debug("\tTriangle %d generated %d pixels\n", i, list_count(pixel_list));
				}
				/* Clean pixels */
				opengl_sc_rast_triangle_done(pixel_list);
			}
			opengl_pa_primitives_free(prmtv);
		}

		/* Debug: export target */
		opengl_debug("\texport target pos #%d\n", pos_idx);
		LIST_FOR_EACH(pos_lst, i)
		{
			pos = list_get(pos_lst, i);
			opengl_debug("\t\t%d: %f, %f, %f, %f\n", i, pos[0], pos[1], pos[2], pos[3]);
		}
	}


	/* Reset Shader Export */
	SISXReset(si_emu->sx);

	/* Return */
	return 0;
}
