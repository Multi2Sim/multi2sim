/*
 *  Multi2Sim
 *  Copyright (C) 2012  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <assert.h>

#include <arch/x86/emu/emu.h>
#include <arch/x86/emu/context.h>
#include <arch/x86/emu/regs.h>
#include <arch/southern-islands/emu/ndrange.h>
#include <arch/southern-islands/emu/opengl-bin-file.h>
#include <driver/glut/frame-buffer.h>
#include <lib/mhandle/mhandle.h>
#include <lib/util/debug.h>
#include <lib/util/list.h>
#include <lib/util/misc.h>
#include <lib/util/string.h>
#include <mem-system/memory.h>

#include "opengl.h"
#include "si-program.h"
#include "si-shader.h"

/* Debug */
int opengl_debug_category;

#define SI_DRIVER_MAX_WORK_GROUP_BUFFER_SIZE 16

/* Error messages */
static char *opengl_err_not_impl =
	"\tThe OpenGL interface is implemented in library 'm2s-opengl.so' as a set of\n"
	"\tsystem calls, intercepted by Multi2Sim and emulated in 'opengl.c'.\n"
	"\tHowever, only a subset of this interface is currently implemented in the simulator.\n"
	"\tTo request the implementation of a specific OpenGL call, please email\n"
	"\t'development@multi2sim.org'.\n";

static char *opengl_version_code =
	"\tAn invalid function code was generated by your application in a OpenGL system\n"
	"\tcall. Probably, this means that your application is using an incompatible\n"
	"\tversion of the Multi2Sim OpenGL runtime library ('libm2s-opengl'). Please\n"
	"\trecompile your application and try again.\n";

struct opengl_abi_si_driver_state_t
{
	struct opengl_si_shader_t *shader;
	struct si_ndrange_t *ndrange;
	int ready_for_work;
	int wait_for_ndrange_completion;
	int ndrange_complete;
};

struct opengl_abi_si_driver_state_t driver_state;


/* List of OpenGL Runtime calls */
enum opengl_abi_call_t
{
	opengl_abi_call_invalid = 0,
#define OPENGL_ABI_CALL(name, code) opengl_abi_##name = code,
#include "opengl.dat"
#undef OPENGL_ABI_CALL
	opengl_abi_call_count
};


/* List of OpenGL ABI call names */
char *opengl_abi_call_name[opengl_abi_call_count + 1] =
{
	NULL,
#define OPENGL_ABI_CALL(name, code) #name,
#include "opengl.dat"
#undef OPENGL_ABI_CALL
	NULL
};

/* Forward declarations of OpenGL Runtime functions */
#define OPENGL_ABI_CALL(name, code) \
	static int opengl_abi_##name##_impl(struct x86_ctx_t *ctx);
#include "opengl.dat"
#undef OPENGL_ABI_CALL


/* List of OpenGL Runtime functions */
typedef int (*opengl_abi_call_t)(struct x86_ctx_t *ctx);
static opengl_abi_call_t opengl_abi_call_table[opengl_abi_call_count + 1] =
{
	NULL,
#define OPENGL_ABI_CALL(name, code) opengl_abi_##name##_impl,
#include "opengl.dat"
#undef OPENGL_ABI_CALL
	NULL
};


#define __NOT_IMPL__  fatal("%s: not implemented.\n%s", \
	__FUNCTION__, opengl_err_not_impl);

/*
 * OpenGL global variables
 */

/* OpenGL Context */
struct opengl_context_t *opengl_driver_ctx;

void opengl_init(void)
{
}


void opengl_done(void)
{
}


int opengl_abi_call(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;

	/* Variables */
	int code;
	int ret;

	/* Function code */
	code = regs->ebx;
	if (code <= opengl_abi_call_invalid || code >= opengl_abi_call_count)
		fatal("%s: invalid OpenGL function (code %d).\n%s",
			__FUNCTION__, code, opengl_version_code);

	/* Debug */
	opengl_debug("OpenGL runtime call '%s' (code %d)\n",
		opengl_abi_call_name[code], code);

	/* Call OPENGL function */
	assert(opengl_abi_call_table[code]);
	ret = opengl_abi_call_table[code](ctx);

	/* Return value */
	return ret;
}


/*
 * OpenGL ABI call #1 - init
 *
 * Returns the version of the OpenGL driver.
 *
 * @param struct opengl_version_t *version
 *
 * 	The driver returns its version information in this argument, with a
 * 	data structure formed of two integer fields:
 *
 * 	struct opengl_version_t
 * 	{
 * 		int major;
 * 		int minor;
 * 	};
 *
 * @return
 *	The function always returns 0.
 */

/* NOTE: when modifying the values of these two macros, the same values should
 * be reflected in 'runtime/opengl/context.c'. */
#define OPENGL_VERSION_MAJOR  1
#define OPENGL_VERSION_MINOR  1000

struct opengl_version_t
{
	int major;
	int minor;
};

static int opengl_abi_init_impl(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int version_ptr;
	struct opengl_version_t version;

	/* Arguments */
	version_ptr = regs->ecx;
	opengl_debug("\tversion_ptr=0x%x\n", version_ptr);

	/* Return version */
	assert(sizeof(struct opengl_version_t) == 8);
	version.major = OPENGL_VERSION_MAJOR;
	version.minor = OPENGL_VERSION_MINOR;
	mem_write(mem, version_ptr, sizeof version, &version);
	opengl_debug("\tMulti2Sim OpenGL implementation in host: v. %d.%d.\n",
		OPENGL_VERSION_MAJOR, OPENGL_VERSION_MINOR);
	opengl_debug("\tMulti2Sim OpenGL Runtime in guest: v. %d.%d.\n",
		version.major, version.minor);

	/* Return success */
	return 0;
}

/*
 * OpenGL ABI call #2 - done
 *
 * Finialize, free all created objects 
 *
 * @return
 *	The function always returns 0.
 */

static int opengl_abi_done_impl(struct x86_ctx_t *ctx)
{
	/* Free */
	opengl_si_program_list_done();

	/* Return success */
	return 0;
}

/*
 * OpenGL ABI call #3 - si_mem_alloc
 *
 * Allocates memory in the Southern Islands device.
 *
 * @param unsigned int size
 *
 * 	Number of bytes to allocate.
 *
 * @return void *
 *
 *	The function returns a pointer in the device memory space. This pointer
 *	should not be dereferenced in the runtime, but instead passed to other
 *	ABI calls taking device pointers as input arguments.
 */

static int opengl_abi_si_mem_alloc_impl(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;

	unsigned int size;
	unsigned int device_ptr;

	/* Arguments */
	size = regs->ecx;
	opengl_debug("\tsize = %u\n", size);

	/* For now, memory allocation in device memory is done by just 
	 * incrementing a pointer to the top of the global memory space. 
	 * Since memory deallocation is not implemented, "holes" in the 
	 * memory space are not considered. */
	device_ptr = si_emu->video_mem_top;
	si_emu->video_mem_top += size;
	opengl_debug("\t%d bytes of device memory allocated at 0x%x\n",
			size, device_ptr);

	/* Return device pointer */
	return device_ptr;
}




/*
 * OpenGL ABI call #4 - si_mem_read
 *
 * Read memory from Southern Islands device into host memory space.
 *
 * @param void *host_ptr
 *
 * 	Destination pointer in host memory space.
 *
 * @param void *device_ptr
 *
 * 	Source pointer in device memory space.
 *
 * @param unsigned int size
 *
 * 	Number of bytes to read.
 *
 * @return void
 *
 *	The function does not have any return value.
 */

static int opengl_abi_si_mem_read_impl(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int host_ptr;
	unsigned int device_ptr;
	unsigned int size;

	void *buf;

	/* Arguments */
	host_ptr = regs->ecx;
	device_ptr = regs->edx;
	size = regs->esi;
	opengl_debug("\thost_ptr = 0x%x, device_ptr = 0x%x, size = %d bytes\n",
			host_ptr, device_ptr, size);

	/* Check memory range */
	if (device_ptr + size > si_emu->video_mem_top)
		fatal("%s: accessing device memory not allocated",
				__FUNCTION__);

	/* Read memory from device to host */
	buf = xmalloc(size);
	mem_read(si_emu->video_mem, device_ptr, size, buf);
	mem_write(mem, host_ptr, size, buf);
	free(buf);

	/* Return */
	return 0;
}




/*
 * OpenGL ABI call #5 - si_mem_write
 *
 * Write memory from host into Southern Islands device.
 *
 * @param void *device_ptr
 *
 * 	Destination pointer in device memory.
 *
 * @param void *host_ptr
 *
 * 	Source pointer in host memory.
 *
 * @param unsigned int size
 *
 * 	Number of bytes to read.
 *
 * @return void
 *
 *	The function does not have any return value.
 */

static int opengl_abi_si_mem_write_impl(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int device_ptr;
	unsigned int host_ptr;
	unsigned int size;

	void *buf;

	/* Arguments */
	device_ptr = regs->ecx;
	host_ptr = regs->edx;
	size = regs->esi;
	opengl_debug("\tdevice_ptr = 0x%x, host_ptr = 0x%x, size = %d bytes\n",
			device_ptr, host_ptr, size);

	/* Check memory range */
	if (device_ptr + size > si_emu->video_mem_top)
		fatal("%s: accessing device memory not allocated",
				__FUNCTION__);

	/* Write memory from host to device */
	buf = xmalloc(size);
	mem_read(mem, host_ptr, size, buf);
	mem_write(si_emu->video_mem, device_ptr, size, buf);
	free(buf);

	/* Return */
	return 0;
}




/*
 * OpenGL ABI call #6 - si_mem_copy
 *
 * Copy memory across two different regions of the Southern Islands device
 * memory space.
 *
 * @param void *dest_ptr
 *
 * 	Destination pointer in device memory.
 *
 * @param void *src_ptr
 *
 * 	Source pointer in device memory.
 *
 * @param unsigned int size
 *
 * 	Number of bytes to read.
 *
 * @return void
 *
 *	The function does not have any return value.
 */

static int opengl_abi_si_mem_copy_impl(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;

	unsigned int dest_ptr;
	unsigned int src_ptr;
	unsigned int size;

	void *buf;

	/* Arguments */
	dest_ptr = regs->ecx;
	src_ptr = regs->edx;
	size = regs->esi;
	opengl_debug("\tdest_ptr = 0x%x, src_ptr = 0x%x, size = %d bytes\n",
			dest_ptr, src_ptr, size);

	/* Check memory range */
	if (src_ptr + size > si_emu->video_mem_top ||
			dest_ptr + size > si_emu->video_mem_top)
		fatal("%s: accessing device memory not allocated",
				__FUNCTION__);

	/* Write memory from host to device */
	buf = xmalloc(size);
	mem_read(si_emu->video_mem, src_ptr, size, buf);
	mem_write(si_emu->video_mem, dest_ptr, size, buf);
	free(buf);

	/* Return */
	return 0;
}


/*
 * OpenGL ABI call #7 - si_mem_free
 *
 * Deallocated memory in Southern Islands global memory scope.
 *
 * @param unsigned int device_ptr
 *
 * 	Memory address in device global memory returned previously by a call to
 *	'si_mem_alloc'.
 *
 * @return void
 *
 *	No value is returned.
 */

static int opengl_abi_si_mem_free_impl(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;

	unsigned int device_ptr;

	/* Arguments */
	device_ptr = regs->ecx;
	opengl_debug("\tdevice_ptr = %u\n", device_ptr);

	/* For now, this call is ignored. No deallocation of global memory can
	 * happen. */

	/* Return device pointer */
	return device_ptr;
}



/*
 * OpenGL ABI call #8 - si_program_create
 *
 * Create a Southern Islands program object 
 *
 * @return int
 *
 *	No value is returned.
 */

static int opengl_abi_si_program_create_impl(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct opengl_si_program_t *program;
	unsigned int program_id;

	/* Arguments */
	program_id = regs->ecx;

	/* Create program */
	program = opengl_si_program_create(program_id);
	opengl_debug("\tnew program ID = %d\n", program->id);

	/* Return program ID */
	return program->id;
}




/*
 * OpenGL ABI call #9 - si_program_set_binary
 *
 * Associate a binary to a Southern Islands program.
 *
 * @param int program_id
 *
 * 	Program ID, as returned by a previous ABI call to 'si_program_create'.
 *
 * @param void *buf
 *
 * 	Pointer to the memory space where the program binary can be found.
 *
 * @param unsigned int size
 *
 * 	Size of the program binary
 *
 * @return void
 *
 *	No return value.
 */

static int opengl_abi_si_program_set_binary_impl(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct opengl_si_program_t *program;

	int program_id;
	unsigned int bin_ptr;
	unsigned int bin_size;

	void *buf;

	/* Arguments */
	program_id = regs->ecx;
	bin_ptr = regs->edx;
	bin_size = regs->esi;
	opengl_debug("\tprogram_id=%d, bin_ptr=0x%x, size=%u\n",
			program_id, bin_ptr, bin_size);

	/* Get program */
	program = list_get(opengl_si_program_list, program_id);
	if (!program)
		fatal("%s: invalid program ID (%d)",
				__FUNCTION__, program_id);

	/* Set the binary */
	buf = xmalloc(bin_size);
	mem_read(ctx->mem, bin_ptr, bin_size, buf);
	opengl_si_program_set_binary(program, buf, bin_size);
	free(buf);
	
	/* No return value */
	return 0;
}



/*
 * OpenGL ABI call #10 - si_shader_create
 *
 * Create a Southern Islands shader object and return a unique identifier
 * for it.
 *
 * @param int program_id
 *
 * 	Program ID, as returned by ABI call 'si_program_create'
 *
 * @param char *func_name
 *
 * 	Kernel function name in the program.
 *
 * @return int
 *
 *	Unique shader ID.
 */

static int opengl_abi_si_shader_create_impl(struct x86_ctx_t *ctx)
{
	__NOT_IMPL__
	return 0;
}



/*
 * OpenGL ABI call #11 - si_ndrange_initialize
 *
 * Create and initialize an ND-Range for the supplied shader.
 *
 * @param int shader_id
 *
 * 	Kernel ID, as returned by ABI call 'si_shader_create'
 *
 * @param int work_dim
 *
 * 	Number of work dimensions. This is an integer number between 1 and 3,
 * 	which determines the number of elements of the following arrays.
 *
 * @param unsigned int *global_offset
 *
 *	Array of 'work_dim' integers containing global offsets.
 *
 * @param unsigned int *global_size
 *
 *	Array of 'work_dim' integers containing the ND-Range global size in each
 *	dimension.
 *
 * @param unsigned int *local_size
 *
 *	Array of 'work_dim' integers containing the local size in each
 *	dimension.
 *
 * @return int
 *
 *	Unique shader ID.
 */

static int opengl_abi_si_ndrange_initialize_impl(struct x86_ctx_t *ctx)
{
	__NOT_IMPL__

	/* No return value */
	return 0;
}




/*
 * OpenGL ABI call #12 - si_ndrange_get_num_buffer_entries
 *
 * Returns the number of available buffer entries in the waiting 
 * work-group queue.
 *
 * @param unsigned int *host_ptr
 *
 *	Location to be populated with the number of available 
 *	buffer entry slots.
 *
 * @return int
 *
 *	The function always returns 0.
 */


static int opengl_abi_si_ndrange_get_num_buffer_entries_impl(
	struct x86_ctx_t *ctx)
{
	__NOT_IMPL__
	return 0;
}

/*
 * OpenGL ABI call #13 - si_ndrange_send_work_groups
 *
 * Receives a range of work-group IDs to add to the waiting 
 * work-group queue. The x86 context performing this call
 * suspends until the emulator needs more work.
 *
 * @param int work_group_start_id 
 *
 *	The first work-group ID to add to the waiting queue.
 *
 * @param int work_group_count
 *
 *	The number of work groups to add to the waiting queue.
 *
 * @return int
 *
 *	The function always returns 0.
 */

static int opengl_abi_si_ndrange_send_work_groups_can_wakeup(
	struct x86_ctx_t *ctx, void *user_data)
{
	assert(!user_data);

	return driver_state.ready_for_work;
}

static void opengl_abi_si_ndrange_send_work_groups_wakeup(
	struct x86_ctx_t *ctx, void *user_data)
{
	assert(!user_data);
}

static int opengl_abi_si_ndrange_send_work_groups_impl(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;

	int i;
	int work_group_count;
	int work_group_start_id;

	long work_group_id;

	/* Arguments */
	work_group_start_id = regs->ecx;
	work_group_count = regs->edx;

	assert(work_group_count <= SI_DRIVER_MAX_WORK_GROUP_BUFFER_SIZE -
		list_count(si_emu->waiting_work_groups));

	opengl_debug("    receiving work groups %d through %d\n",
		work_group_start_id, work_group_start_id+work_group_count-1);

	/* Receive work groups (add them to the waiting queue) */
	for (i = 0; i < work_group_count; i++)
	{
		work_group_id = work_group_start_id + i;
		list_enqueue(si_emu->waiting_work_groups, (void*)work_group_id);
	}

	/* XXX Later, check if waiting queue is still under a threshold.  
	 * If it is, set as ready for work */
	driver_state.ready_for_work = 0;

	/* Suspend x86 context until driver needs more work */
	x86_ctx_suspend(ctx, 
		opengl_abi_si_ndrange_send_work_groups_can_wakeup, NULL,
		opengl_abi_si_ndrange_send_work_groups_wakeup, NULL);

	return 0;
}

/*
 * OpenGL ABI call #14 - si_ndrange_finish
 *
 * Tells the driver that there are no more work groups to execute
 * from the ND-Range.
 *
 * @return int
 *
 *	The function always returns 0.
 */

static int opengl_abi_si_ndrange_finish_can_wakeup(struct x86_ctx_t *ctx, 
	void *user_data)
{
	assert(!user_data);

	return driver_state.ndrange_complete;
}

static void opengl_abi_si_ndrange_finish_wakeup(struct x86_ctx_t *ctx, 
	void *user_data)
{
	assert(!user_data);

	/* Reset driver state */
	si_ndrange_free(driver_state.ndrange);
	driver_state.ndrange = NULL;
	driver_state.shader = NULL;
	driver_state.wait_for_ndrange_completion = 0;
	driver_state.ndrange_complete = 0;
	driver_state.ready_for_work = 0;

	si_emu->ndrange = NULL;
}

static int opengl_abi_si_ndrange_finish_impl(struct x86_ctx_t *ctx)
{
	driver_state.wait_for_ndrange_completion = 1;

	if (!list_count(si_emu->running_work_groups) && 
		!list_count(si_emu->waiting_work_groups))
	{
		/* Reset driver state */
		si_ndrange_free(driver_state.ndrange);
		driver_state.ndrange = NULL;
		driver_state.shader = NULL;
		driver_state.wait_for_ndrange_completion = 0;
		driver_state.ndrange_complete = 0;
		driver_state.ready_for_work = 0;

		si_emu->ndrange = NULL;
	}
	else 
	{
		/* Suspend x86 context until simulation completes */
		x86_ctx_suspend(ctx, opengl_abi_si_ndrange_finish_can_wakeup, 
			NULL, opengl_abi_si_ndrange_finish_wakeup, NULL);
	}

	return 0;
}


/*
 * OpenGL ABI call #15 - si_ndrange_pass_mem_objs
 *
 * @return int
 *
 *	The function always returns 0.
 */

static int opengl_abi_si_ndrange_pass_mem_objs_impl(struct x86_ctx_t *ctx)
{
	__NOT_IMPL__
	return 0;
}

