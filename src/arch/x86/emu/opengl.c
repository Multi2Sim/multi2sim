/*
 *  Multi2Sim
 *  Copyright (C) 2011  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <x86-emu.h>
#include <mem-system.h>
#include <GL/gl.h>

static char *err_x86_opengl_code =
	"\tAn invalid function code was generated by your application in a OpenGL system\n"
	"\tcall. Probably, this means that your application is using an incompatible\n"
	"\tversion of the Multi2Sim OpenGL runtime library ('libm2s-opengl'). Please\n"
	"\trecompile your application and try again.\n";


/* Debug */
int x86_opengl_debug_category;


/* List of OPENGL runtime calls */
enum x86_opengl_call_t
{
	x86_opengl_call_invalid = 0,
#define X86_OPENGL_DEFINE_CALL(name, code) x86_opengl_call_##name = code,
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL
	x86_opengl_call_count
};


/* List of OPENGL runtime call names */
char *x86_opengl_call_name[x86_opengl_call_count + 1] =
{
	NULL,
#define X86_OPENGL_DEFINE_CALL(name, code) #name,
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL
	NULL
};


/* Forward declarations of OPENGL runtime functions */
#define X86_OPENGL_DEFINE_CALL(name, code) static int x86_opengl_func_##name(void);
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL


/* List of OPENGL runtime functions */
typedef int (*x86_opengl_func_t)(void);
static x86_opengl_func_t x86_opengl_func_table[x86_opengl_call_count + 1] =
{
	NULL,
#define X86_OPENGL_DEFINE_CALL(name, code) x86_opengl_func_##name,
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL
	NULL
};


/*
 * OpenGL Global variables
 */


void x86_opengl_init(void)
{

}


void x86_opengl_done(void)
{

}


int x86_opengl_call(void)
{
	int code;
	int ret;

	/* Function code */
	code = x86_isa_regs->ebx;
	if (code <= x86_opengl_call_invalid || code >= x86_opengl_call_count)
		fatal("%s: invalid OpenGL function (code %d).\n%s",
			__FUNCTION__, code, err_x86_opengl_code);

	/* Debug */
	x86_opengl_debug("OpenGL runtime call '%s' (code %d)\n",
		x86_opengl_call_name[code], code);

	/* Call OPENGL function */
	assert(x86_opengl_func_table[code]);
	ret = x86_opengl_func_table[code]();

	/* Return value */
	return ret;
}




/*
 * OPENGL call #1 - init
 *
 * @param struct x86_opengl_version_t *version;
 *	Structure where the version of the OpenGL runtime implementation will be
 *	dumped. To succeed, the major version should match in the runtime
 *	library (guest) and runtime implementation (host), whereas the minor
 *	version should be equal or higher in the implementation (host).
 *
 *	Features should be added to the OpenGL runtime (guest and host) using the
 *	following rules:
 *	1)  If the guest library requires a new feature from the host
 *	    implementation, the feature is added to the host, and the minor
 *	    version is updated to the current Multi2Sim SVN revision both in
 *	    host and guest.
 *          All previous services provided by the host should remain available
 *          and backward-compatible. Executing a newer library on the older
 *          simulator will fail, but an older library on the newer simulator
 *          will succeed.
 *      2)  If a new feature is added that affects older services of the host
 *          implementation breaking backward compatibility, the major version is
 *          increased by 1 in the host and guest code.
 *          Executing a library with a different (lower or higher) major version
 *          than the host implementation will fail.
 *
 * @return
 *	The runtime implementation version is return in argument 'version'.
 *	The return value is always 0.
 */

#define X86_OPENGL_RUNTIME_VERSION_MAJOR	0
#define X86_OPENGL_RUNTIME_VERSION_MINOR	669

struct x86_opengl_version_t
{
	int major;
	int minor;
};

static int x86_opengl_func_init(void)
{
	unsigned int version_ptr;

	struct x86_opengl_version_t version;

	/* Arguments */
	version_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tversion_ptr=0x%x\n", version_ptr);

	/* Return version */
	assert(sizeof(struct x86_opengl_version_t) == 8);
	version.major = X86_OPENGL_RUNTIME_VERSION_MAJOR;
	version.minor = X86_OPENGL_RUNTIME_VERSION_MINOR;
	mem_write(x86_isa_mem, version_ptr, 8, &version);
	x86_opengl_debug("\tOpenGL Runtime host implementation v. %d.%d\n", version.major, version.minor);

	/* Return success */
	return 0;
}

/*
 * GLUT call #1 - glEnable
 *
 * glEnable - enable server-side GL capabilities
 *
 * @return
 *	The function always returns 0
 */

 struct x86_opengl_server_capability
{
	GLboolean is_alpha_test;
	GLboolean is_auto_normal;
	GLboolean is_blend;
	GLboolean is_clip_plane0;
	GLboolean is_clip_plane1;
	GLboolean is_clip_plane2;
	GLboolean is_clip_plane3;
	GLboolean is_clip_plane4;
	GLboolean is_clip_plane5;
	GLboolean is_color_logic_op;
	GLboolean is_color_material;
	GLboolean is_color_sum;
	GLboolean is_color_table;
	GLboolean is_convolution_1d;
	GLboolean is_convolution_2d;
	GLboolean is_cull_face;
	GLboolean is_depth_test;
	GLboolean is_dither;
	GLboolean is_fog;
	GLboolean is_histogram;
	GLboolean is_index_logic_op;
	GLboolean is_light0;
	GLboolean is_light1;
	GLboolean is_light2;
	GLboolean is_light3;
	GLboolean is_light4;
	GLboolean is_light5;
	GLboolean is_light6;
	GLboolean is_light7;
	GLboolean is_lighting;
	GLboolean is_line_smooth;
	GLboolean is_line_stipple;
	GLboolean is_map1_color_4;
	GLboolean is_map1_index;
	GLboolean is_map1_normal;
	GLboolean is_map1_texture_coord_1;
	GLboolean is_map1_texture_coord_2;
	GLboolean is_map1_texture_coord_3;
	GLboolean is_map1_texture_coord_4;
	GLboolean is_map1_vertex_3;
	GLboolean is_map1_vertex_4;
	GLboolean is_map2_color_4;
	GLboolean is_map2_index;
	GLboolean is_map2_normal;
	GLboolean is_map2_texture_coord_1;
	GLboolean is_map2_texture_coord_2;
	GLboolean is_map2_texture_coord_3;
	GLboolean is_map2_texture_coord_4;
	GLboolean is_map2_vertex_3;
	GLboolean is_map2_vertex_4;
	GLboolean is_minmax;
	GLboolean is_multisample;
	GLboolean is_normalize;
	GLboolean is_point_smooth;
	GLboolean is_point_sprite;
	GLboolean is_polygon_offset_fill;
	GLboolean is_polygon_offset_line;
	GLboolean is_polygon_offset_point;
	GLboolean is_polygon_smooth;
	GLboolean is_polygon_stipple;
	GLboolean is_post_color_matrix_color_table;
	GLboolean is_post_convolution_color_table;
	GLboolean is_rescale_normal;
	GLboolean is_sample_alpha_to_coverage;
	GLboolean is_sample_alpha_to_one;
	GLboolean is_sample_coverage;
	GLboolean is_separable_2d;
	GLboolean is_scissor_test;
	GLboolean is_stencil_test;
	GLboolean is_texture_1d;
	GLboolean is_texture_2d;
	GLboolean is_texture_3d;
	GLboolean is_texture_cube_map;
	GLboolean is_texture_gen_q;
	GLboolean is_texture_gen_r;
	GLboolean is_texture_gen_s;
	GLboolean is_texture_gen_t;
	GLboolean is_vertex_program_point_size;
	GLboolean is_vertex_program_two_side;
};

static struct x86_opengl_server_capability *x86_opengl_server_capability = NULL;

 void x86_opengl_server_capability_init(void)
 {
 	x86_opengl_server_capability = calloc(1, sizeof(struct x86_opengl_server_capability));
	if (!x86_opengl_server_capability)
		fatal("%s: out of memory", __FUNCTION__);

	/* Set up initial value for each capability, initial value for each capability is GL_FALSE, except GL_DITHER and GL_MULTISAMPLE */
	memset(x86_opengl_server_capability, 0, sizeof(struct x86_opengl_server_capability));
	x86_opengl_server_capability->is_dither = GL_TRUE;
	x86_opengl_server_capability->is_multisample = GL_TRUE;
 }

/* FIXME: when to release?  */
void x86_opengl_server_capability_done(void)
{
	free(x86_opengl_server_capability);
}

static int x86_opengl_func_glEnable(void)
{
	unsigned int cap_ptr;

	/* Read arguments */
	cap_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tevent_ptr=0x%x\n", cap_ptr);

	GLenum cap;

	mem_read(x86_isa_mem, cap_ptr, sizeof(GLenum),&cap);

	/* If the server capability not available, set it up */
	if (x86_opengl_server_capability == NULL)
	{
		x86_opengl_server_capability_init();
	}

	switch(cap)
	{

	case GL_ALPHA_TEST:

		{
			x86_opengl_server_capability->is_alpha_test = GL_TRUE;
			x86_opengl_debug("GL_ALPHA_TEST enabled!");
			break;
		}

	case GL_AUTO_NORMAL:

		{
			x86_opengl_server_capability->is_auto_normal = GL_TRUE;
			x86_opengl_debug("GL_AUTO_NORMAL enabled!");
			break;
		}

	case GL_BLEND:

		{
			x86_opengl_server_capability->is_blend = GL_TRUE;
			x86_opengl_debug("GL_BLEND enabled!");
			break;
		}

	case GL_CLIP_PLANE0:

		{
			x86_opengl_server_capability->is_clip_plane0 = GL_TRUE;
			x86_opengl_debug("GL_CLIP_PLANE0 enabled!");
			break;
		}

	case GL_CLIP_PLANE1:

		{
			x86_opengl_server_capability->is_clip_plane1 = GL_TRUE;
			x86_opengl_debug("GL_CLIP_PLANE1 enabled!");
			break;
		}

	case GL_CLIP_PLANE2:

		{
			x86_opengl_server_capability->is_clip_plane2 = GL_TRUE;
			x86_opengl_debug("GL_CLIP_PLANE2 enabled!");
			break;
		}

	case GL_CLIP_PLANE3:

		{
			x86_opengl_server_capability->is_clip_plane3 = GL_TRUE;
			x86_opengl_debug("GL_CLIP_PLANE3 enabled!");
			break;
		}

	case GL_CLIP_PLANE4:

		{
			x86_opengl_server_capability->is_clip_plane4 = GL_TRUE;
			x86_opengl_debug("GL_CLIP_PLANE4 enabled!");
			break;
		}

	case GL_CLIP_PLANE5:

		{
			x86_opengl_server_capability->is_clip_plane5 = GL_TRUE;
			x86_opengl_debug("GL_CLIP_PLANE5 enabled!");
			break;
		}

	case GL_COLOR_LOGIC_OP:

		{
			x86_opengl_server_capability->is_color_logic_op = GL_TRUE;
			x86_opengl_debug("GL_COLOR_LOGIC_OP enabled!");
			break;
		}

	case GL_COLOR_MATERIAL:

		{
			x86_opengl_server_capability->is_color_material = GL_TRUE;
			x86_opengl_debug("GL_COLOR_MATERIAL enabled!");
			break;
		}

	case GL_COLOR_SUM:

		{
			x86_opengl_server_capability->is_color_sum = GL_TRUE;
			x86_opengl_debug("GL_COLOR_SUM enabled!");
			break;
		}

	case GL_COLOR_TABLE:

		{
			x86_opengl_server_capability->is_color_table = GL_TRUE;
			x86_opengl_debug("GL_COLOR_TABLE enabled!");
			break;
		}

	case GL_CONVOLUTION_1D:

		{
			x86_opengl_server_capability->is_convolution_1d = GL_TRUE;
			x86_opengl_debug("GL_CONVOLUTION_1D enabled!");
			break;
		}

	case GL_CONVOLUTION_2D:

		{
			x86_opengl_server_capability->is_convolution_2d = GL_TRUE;
			x86_opengl_debug("GL_CONVOLUTION_2D enabled!");
			break;
		}

	case GL_CULL_FACE:

		{
			x86_opengl_server_capability->is_cull_face = GL_TRUE;
			x86_opengl_debug("GL_CULL_FACE enabled!");
			break;
		}

	case GL_DEPTH_TEST:

		{
			x86_opengl_server_capability->is_depth_test = GL_TRUE;
			x86_opengl_debug("GL_DEPTH_TEST enabled!");
			break;
		}

	case GL_DITHER:

		{
			x86_opengl_server_capability->is_dither = GL_TRUE;
			x86_opengl_debug("GL_DITHER enabled!");
			break;
		}

	case GL_FOG:

		{
			x86_opengl_server_capability->is_fog = GL_TRUE;
			x86_opengl_debug("GL_FOG enabled!");
			break;
		}

	case GL_HISTOGRAM:

		{
			x86_opengl_server_capability->is_histogram = GL_TRUE;
			x86_opengl_debug("GL_HISTOGRAM enabled!");
			break;
		}

	case GL_INDEX_LOGIC_OP:

		{
			x86_opengl_server_capability->is_index_logic_op = GL_TRUE;
			x86_opengl_debug("GL_INDEX_LOGIC_OP enabled!");
			break;
		}

	case GL_LIGHT0:

		{
			x86_opengl_server_capability->is_light0 = GL_TRUE;
			x86_opengl_debug("GL_LIGHT0 enabled!");
			break;
		}

	case GL_LIGHT1:

		{
			x86_opengl_server_capability->is_light1 = GL_TRUE;
			x86_opengl_debug("GL_LIGHT1 enabled!");
			break;
		}

	case GL_LIGHT2:

		{
			x86_opengl_server_capability->is_light2 = GL_TRUE;
			x86_opengl_debug("GL_LIGHT2 enabled!");
			break;
		}

	case GL_LIGHT3:

		{
			x86_opengl_server_capability->is_light3 = GL_TRUE;
			x86_opengl_debug("GL_LIGHT3 enabled!");
			break;
		}

	case GL_LIGHT4:

		{
			x86_opengl_server_capability->is_light4 = GL_TRUE;
			x86_opengl_debug("GL_LIGHT4 enabled!");
			break;
		}

	case GL_LIGHT5:

		{
			x86_opengl_server_capability->is_light5 = GL_TRUE;
			x86_opengl_debug("GL_LIGHT5 enabled!");
			break;
		}

	case GL_LIGHT6:

		{
			x86_opengl_server_capability->is_light6 = GL_TRUE;
			x86_opengl_debug("GL_LIGHT6 enabled!");
			break;
		}

	case GL_LIGHT7:

		{
			x86_opengl_server_capability->is_light7 = GL_TRUE;
			x86_opengl_debug("GL_LIGHT7 enabled!");
			break;
		}

	case GL_LIGHTING:

		{
			x86_opengl_server_capability->is_lighting = GL_TRUE;
			x86_opengl_debug("GL_LIGHTING enabled!");
			break;
		}

	case GL_LINE_SMOOTH:

		{
			x86_opengl_server_capability->is_line_smooth = GL_TRUE;
			x86_opengl_debug("GL_LINE_SMOOTH enabled!");
			break;
		}

	case GL_LINE_STIPPLE:

		{
			x86_opengl_server_capability->is_line_stipple = GL_TRUE;
			x86_opengl_debug("GL_LINE_STIPPLE enabled!");
			break;
		}

	case GL_MAP1_COLOR_4:

		{
			x86_opengl_server_capability->is_map1_color_4 = GL_TRUE;
			x86_opengl_debug("GL_MAP1_COLOR_4 enabled!");
			break;
		}

	case GL_MAP1_INDEX:

		{
			x86_opengl_server_capability->is_map1_index = GL_TRUE;
			x86_opengl_debug("GL_MAP1_INDEX enabled!");
			break;
		}

	case GL_MAP1_NORMAL:

		{
			x86_opengl_server_capability->is_map1_normal = GL_TRUE;
			x86_opengl_debug("GL_MAP1_NORMAL enabled!");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_1:

		{
			x86_opengl_server_capability->is_map1_texture_coord_1 = GL_TRUE;
			x86_opengl_debug("GL_MAP1_TEXTURE_COORD_1 enabled!");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_2:

		{
			x86_opengl_server_capability->is_map1_texture_coord_2 = GL_TRUE;
			x86_opengl_debug("GL_MAP1_TEXTURE_COORD_2 enabled!");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_3:

		{
			x86_opengl_server_capability->is_map1_texture_coord_3 = GL_TRUE;
			x86_opengl_debug("GL_MAP1_TEXTURE_COORD_3 enabled!");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_4:

		{
			x86_opengl_server_capability->is_map1_texture_coord_4 = GL_TRUE;
			x86_opengl_debug("GL_MAP1_TEXTURE_COORD_4 enabled!");
			break;
		}

	case GL_MAP1_VERTEX_3:

		{
			x86_opengl_server_capability->is_map1_vertex_3 = GL_TRUE;
			x86_opengl_debug("GL_MAP1_VERTEX_3 enabled!");
			break;
		}

	case GL_MAP1_VERTEX_4:

		{
			x86_opengl_server_capability->is_map1_vertex_4 = GL_TRUE;
			x86_opengl_debug("GL_MAP1_VERTEX_4 enabled!");
			break;
		}

	case GL_MAP2_COLOR_4:

		{
			x86_opengl_server_capability->is_map2_color_4 = GL_TRUE;
			x86_opengl_debug("GL_MAP2_COLOR_4 enabled!");
			break;
		}

	case GL_MAP2_INDEX:

		{
			x86_opengl_server_capability->is_map2_index = GL_TRUE;
			x86_opengl_debug("GL_MAP2_INDEX enabled!");
			break;
		}

	case GL_MAP2_NORMAL:

		{
			x86_opengl_server_capability->is_map2_normal = GL_TRUE;
			x86_opengl_debug("GL_MAP2_NORMAL enabled!");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_1:

		{
			x86_opengl_server_capability->is_map2_texture_coord_1 = GL_TRUE;
			x86_opengl_debug("GL_MAP2_TEXTURE_COORD_1 enabled!");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_2:

		{
			x86_opengl_server_capability->is_map2_texture_coord_2 = GL_TRUE;
			x86_opengl_debug("GL_MAP2_TEXTURE_COORD_2 enabled!");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_3:

		{
			x86_opengl_server_capability->is_map2_texture_coord_3 = GL_TRUE;
			x86_opengl_debug("GL_MAP2_TEXTURE_COORD_3 enabled!");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_4:

		{
			x86_opengl_server_capability->is_map2_texture_coord_4 = GL_TRUE;
			x86_opengl_debug("GL_MAP2_TEXTURE_COORD_4 enabled!");
			break;
		}

	case GL_MAP2_VERTEX_3:

		{
			x86_opengl_server_capability->is_map2_vertex_3 = GL_TRUE;
			x86_opengl_debug("GL_MAP2_VERTEX_3 enabled!");
			break;
		}

	case GL_MAP2_VERTEX_4:

		{
			x86_opengl_server_capability->is_map2_vertex_4 = GL_TRUE;
			x86_opengl_debug("GL_MAP2_VERTEX_4 enabled!");
			break;
		}

	case GL_MINMAX:

		{
			x86_opengl_server_capability->is_minmax = GL_TRUE;
			x86_opengl_debug("GL_MINMAX enabled!");
			break;
		}

	case GL_MULTISAMPLE:

		{
			x86_opengl_server_capability->is_multisample = GL_TRUE;
			x86_opengl_debug("GL_MULTISAMPLE enabled!");
			break;
		}

	case GL_NORMALIZE:

		{
			x86_opengl_server_capability->is_normalize = GL_TRUE;
			x86_opengl_debug("GL_NORMALIZE enabled!");
			break;
		}

	case GL_POINT_SMOOTH:

		{
			x86_opengl_server_capability->is_point_smooth = GL_TRUE;
			x86_opengl_debug("GL_POINT_SMOOTH enabled!");
			break;
		}

	case GL_POINT_SPRITE:

		{
			x86_opengl_server_capability->is_point_sprite = GL_TRUE;
			x86_opengl_debug("GL_POINT_SPRITE enabled!");
			break;
		}

	case GL_POLYGON_OFFSET_FILL:

		{
			x86_opengl_server_capability->is_polygon_offset_fill = GL_TRUE;
			x86_opengl_debug("GL_POLYGON_OFFSET_FILL enabled!");
			break;
		}

	case GL_POLYGON_OFFSET_LINE:

		{
			x86_opengl_server_capability->is_polygon_offset_line = GL_TRUE;
			x86_opengl_debug("GL_POLYGON_OFFSET_LINE enabled!");
			break;
		}

	case GL_POLYGON_OFFSET_POINT:

		{
			x86_opengl_server_capability->is_polygon_offset_point = GL_TRUE;
			x86_opengl_debug("GL_POLYGON_OFFSET_POINT enabled!");
			break;
		}

	case GL_POLYGON_SMOOTH:

		{
			x86_opengl_server_capability->is_polygon_smooth = GL_TRUE;
			x86_opengl_debug("GL_POLYGON_SMOOTH enabled!");
			break;
		}

	case GL_POLYGON_STIPPLE:

		{
			x86_opengl_server_capability->is_polygon_stipple = GL_TRUE;
			x86_opengl_debug("GL_POLYGON_STIPPLE enabled!");
			break;
		}

	case GL_POST_COLOR_MATRIX_COLOR_TABLE:

		{
			x86_opengl_server_capability->is_post_color_matrix_color_table = GL_TRUE;
			x86_opengl_debug("GL_POST_COLOR_MATRIX_COLOR_TABLE enabled!");
			break;
		}

	case GL_POST_CONVOLUTION_COLOR_TABLE:

		{
			x86_opengl_server_capability->is_post_convolution_color_table = GL_TRUE;
			x86_opengl_debug("GL_POST_CONVOLUTION_COLOR_TABLE enabled!");
			break;
		}

	case GL_RESCALE_NORMAL:

		{
			x86_opengl_server_capability->is_rescale_normal = GL_TRUE;
			x86_opengl_debug("GL_RESCALE_NORMAL enabled!");
			break;
		}

	case GL_SAMPLE_ALPHA_TO_COVERAGE:

		{
			x86_opengl_server_capability->is_sample_alpha_to_coverage = GL_TRUE;
			x86_opengl_debug("GL_SAMPLE_ALPHA_TO_COVERAGE enabled!");
			break;
		}

	case GL_SAMPLE_ALPHA_TO_ONE:

		{
			x86_opengl_server_capability->is_sample_alpha_to_one = GL_TRUE;
			x86_opengl_debug("GL_SAMPLE_ALPHA_TO_ONE enabled!");
			break;
		}

	case GL_SAMPLE_COVERAGE:

		{
			x86_opengl_server_capability->is_sample_coverage = GL_TRUE;
			x86_opengl_debug("GL_SAMPLE_COVERAGE enabled!");
			break;
		}

	case GL_SEPARABLE_2D:

		{
			x86_opengl_server_capability->is_separable_2d = GL_TRUE;
			x86_opengl_debug("GL_SEPARABLE_2D enabled!");
			break;
		}

	case GL_SCISSOR_TEST:

		{
			x86_opengl_server_capability->is_scissor_test = GL_TRUE;
			x86_opengl_debug("GL_SCISSOR_TEST enabled!");
			break;
		}

	case GL_STENCIL_TEST:

		{
			x86_opengl_server_capability->is_stencil_test = GL_TRUE;
			x86_opengl_debug("GL_STENCIL_TEST enabled!");
			break;
		}

	case GL_TEXTURE_1D:

		{
			x86_opengl_server_capability->is_texture_1d = GL_TRUE;
			x86_opengl_debug("GL_TEXTURE_1D enabled!");
			break;
		}

	case GL_TEXTURE_2D:

		{
			x86_opengl_server_capability->is_texture_2d = GL_TRUE;
			x86_opengl_debug("GL_TEXTURE_2D enabled!");
			break;
		}

	case GL_TEXTURE_3D:

		{
			x86_opengl_server_capability->is_texture_3d = GL_TRUE;
			x86_opengl_debug("GL_TEXTURE_3D enabled!");
			break;
		}

	case GL_TEXTURE_CUBE_MAP:

		{
			x86_opengl_server_capability->is_texture_cube_map = GL_TRUE;
			x86_opengl_debug("GL_TEXTURE_CUBE_MAP enabled!");
			break;
		}

	case GL_TEXTURE_GEN_Q:

		{
			x86_opengl_server_capability->is_texture_gen_q = GL_TRUE;
			x86_opengl_debug("GL_TEXTURE_GEN_Q enabled!");
			break;
		}

	case GL_TEXTURE_GEN_R:

		{
			x86_opengl_server_capability->is_texture_gen_r = GL_TRUE;
			x86_opengl_debug("GL_TEXTURE_GEN_R enabled!");
			break;
		}

	case GL_TEXTURE_GEN_S:

		{
			x86_opengl_server_capability->is_texture_gen_s = GL_TRUE;
			x86_opengl_debug("GL_TEXTURE_GEN_S enabled!");
			break;
		}

	case GL_TEXTURE_GEN_T:

		{
			x86_opengl_server_capability->is_texture_gen_t = GL_TRUE;
			x86_opengl_debug("GL_TEXTURE_GEN_T enabled!");
			break;
		}

	case GL_VERTEX_PROGRAM_POINT_SIZE:

		{
			x86_opengl_server_capability->is_vertex_program_point_size = GL_TRUE;
			x86_opengl_debug("GL_VERTEX_PROGRAM_POINT_SIZE enabled!");
			break;
		}

	case GL_VERTEX_PROGRAM_TWO_SIDE:

		{
			x86_opengl_server_capability->is_vertex_program_two_side = GL_TRUE;
			x86_opengl_debug("GL_VERTEX_PROGRAM_TWO_SIDE enabled!");
			break;
		}

	default:
		break;
	}

	/* Return success */
	return 0;
}

