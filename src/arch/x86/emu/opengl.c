/*
 *  Multi2Sim
 *  Copyright (C) 2011  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <x86-emu.h>
#include <mem-system.h>
#include <GL/gl.h>

static char *err_x86_opengl_code =
	"\tAn invalid function code was generated by your application in a OpenGL system\n"
	"\tcall. Probably, this means that your application is using an incompatible\n"
	"\tversion of the Multi2Sim OpenGL runtime library ('libm2s-opengl'). Please\n"
	"\trecompile your application and try again.\n";

#define X86_OPENGL_MAX_ARGS  14

/* Maximum modelview matrix stack depth */
#define MAX_MODELVIEW_STACK_DEPTH 32

/* Maximum projection matrix stack depth */
#define MAX_PROJECTION_STACK_DEPTH 32

/* Maximum texture matrix stack depth */
#define MAX_TEXTURE_STACK_DEPTH 10

/* FIXME: Maximum color matrix stack depth */ 
#define MAX_COLOR_STACK_DEPTH 32

/* From config.h in Mesa */
#define MAX_TEXTURE_COORD_UNITS 8
#define MAX_TEXTURE_IMAGE_UNITS 16
#define MAX_TEXTURE_UNITS ((MAX_TEXTURE_COORD_UNITS > MAX_TEXTURE_IMAGE_UNITS) ? MAX_TEXTURE_COORD_UNITS : MAX_TEXTURE_IMAGE_UNITS)

#define COLOR_BUFFER_COUNT 4
/* Max number of primitives (number of glBegin/End pairs) per VBO. */
#define VBO_MAX_PRIM 64

/* Size of the VBO to use for glBegin/glVertex/glEnd-style rendering. */
#define VBO_VERT_BUFFER_SIZE (1024*64)	/* bytes */

/* Debug */
int x86_opengl_debug_category;


/* List of OPENGL runtime calls */
enum x86_opengl_call_t
{
	x86_opengl_call_invalid = 0,
#define X86_OPENGL_DEFINE_CALL(name, code) x86_opengl_call_##name = code,
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL
	x86_opengl_call_count
};


/* List of OPENGL runtime call names */
char *x86_opengl_call_name[x86_opengl_call_count + 1] =
{
	NULL,
#define X86_OPENGL_DEFINE_CALL(name, code) #name,
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL
	NULL
};


/* Forward declarations of OPENGL runtime functions */
#define X86_OPENGL_DEFINE_CALL(name, code) static int x86_opengl_func_##name(void);
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL


/* List of OPENGL runtime functions */
typedef int (*x86_opengl_func_t)(void);
static x86_opengl_func_t x86_opengl_func_table[x86_opengl_call_count + 1] =
{
	NULL,
#define X86_OPENGL_DEFINE_CALL(name, code) x86_opengl_func_##name,
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL
	NULL
};


/*
 * OpenGL structures
 */

/* OpenGL context capability */
struct x86_opengl_context_capability_t
{
	GLboolean is_alpha_test;
	GLboolean is_auto_normal;
	GLboolean is_blend;
	GLboolean is_clip_plane0;
	GLboolean is_clip_plane1;
	GLboolean is_clip_plane2;
	GLboolean is_clip_plane3;
	GLboolean is_clip_plane4;
	GLboolean is_clip_plane5;
	GLboolean is_color_logic_op;
	GLboolean is_color_material;
	GLboolean is_color_sum;
	GLboolean is_color_table;
	GLboolean is_convolution_1d;
	GLboolean is_convolution_2d;
	GLboolean is_cull_face;
	GLboolean is_depth_test;
	GLboolean is_dither;
	GLboolean is_fog;
	GLboolean is_histogram;
	GLboolean is_index_logic_op;
	GLboolean is_light0;
	GLboolean is_light1;
	GLboolean is_light2;
	GLboolean is_light3;
	GLboolean is_light4;
	GLboolean is_light5;
	GLboolean is_light6;
	GLboolean is_light7;
	GLboolean is_lighting;
	GLboolean is_line_smooth;
	GLboolean is_line_stipple;
	GLboolean is_map1_color_4;
	GLboolean is_map1_index;
	GLboolean is_map1_normal;
	GLboolean is_map1_texture_coord_1;
	GLboolean is_map1_texture_coord_2;
	GLboolean is_map1_texture_coord_3;
	GLboolean is_map1_texture_coord_4;
	GLboolean is_map1_vertex_3;
	GLboolean is_map1_vertex_4;
	GLboolean is_map2_color_4;
	GLboolean is_map2_index;
	GLboolean is_map2_normal;
	GLboolean is_map2_texture_coord_1;
	GLboolean is_map2_texture_coord_2;
	GLboolean is_map2_texture_coord_3;
	GLboolean is_map2_texture_coord_4;
	GLboolean is_map2_vertex_3;
	GLboolean is_map2_vertex_4;
	GLboolean is_minmax;
	GLboolean is_multisample;
	GLboolean is_normalize;
	GLboolean is_point_smooth;
	GLboolean is_point_sprite;
	GLboolean is_polygon_offset_fill;
	GLboolean is_polygon_offset_line;
	GLboolean is_polygon_offset_point;
	GLboolean is_polygon_smooth;
	GLboolean is_polygon_stipple;
	GLboolean is_post_color_matrix_color_table;
	GLboolean is_post_convolution_color_table;
	GLboolean is_rescale_normal;
	GLboolean is_sample_alpha_to_coverage;
	GLboolean is_sample_alpha_to_one;
	GLboolean is_sample_coverage;
	GLboolean is_separable_2d;
	GLboolean is_scissor_test;
	GLboolean is_stencil_test;
	GLboolean is_texture_1d;
	GLboolean is_texture_2d;
	GLboolean is_texture_3d;
	GLboolean is_texture_cube_map;
	GLboolean is_texture_gen_q;
	GLboolean is_texture_gen_r;
	GLboolean is_texture_gen_s;
	GLboolean is_texture_gen_t;
	GLboolean is_vertex_program_point_size;
	GLboolean is_vertex_program_two_side;
};

/* OpenGL render buffer */
struct x86_opengl_render_buffer_t
{
	GLuint width;
	GLuint height;
	GLuint *buffer;
};

/* OpenGL frame buffer */
struct x86_opengl_frame_buffer_t
{
	GLsizei width;
	GLsizei height;

	/* frame buffer contains a set of render buffers, typically:
	 * 4 color buffers: front left & front right, back left & back right ( FIXME: why 4? )
	 * 1 depth buffer
	 * 1 stencil buffer
	 * Note that accumulation buffer is not defined here( MESA )
	 */
	struct x86_opengl_render_buffer_t *color_buffer[COLOR_BUFFER_COUNT];
	struct x86_opengl_render_buffer_t *depth_buffer;
	struct x86_opengl_render_buffer_t *stencil_buffer;
};

/* OpenGL Viewport attribute */
struct x86_opengl_viewport_attributes_t
{
	/* Position */
	GLint x;
	GLint y;
	/* Size */
	GLsizei width;
	GLsizei height;

	/* FIXME: also found below in Mesa */
	/* Depth buffer range */
	// GLfloat Near;
	// GLfloat Far;

	/* Mapping transformation as a matrix. */
	// GLmatrix _WindowMap; 
};

/* OpenGL: Different kinds of 4x4 transformation matrices */
enum x86_opengl_matrix_mode_t {
	MATRIX_GENERAL,		/* general 4x4 matrix */
	MATRIX_IDENTITY,		/* identity matrix */
	MATRIX_3D_NO_ROT,		/* orthogonal projection and others... */
	MATRIX_PERSPECTIVE,	/* perspective projection matrix */
	MATRIX_2D,			/* 2-D transformation */
	MATRIX_2D_NO_ROT,		/* 2-D scale & translate only */
	MATRIX_3D			/* 3-D transformation */
} ;

/* OpenGL identity matrix */
static GLfloat Identity[16] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
};

/* OpenGL Matrix */
struct x86_opengl_matrix_t
{
	GLfloat *matrix;	/* Points to 4x4 GLfloat type arrays*/
	enum x86_opengl_matrix_mode_t matrix_mode;	
};

/* OpenGL Matrix Stack */
struct x86_opengl_matrix_stack_t
{
	struct list_t *stack;
	GLint depth;
	GLint max_depth;
};

/* OpenGL context*/
struct x86_opengl_context_t
{
	struct x86_opengl_context_capability_t *context_cap;					/* context capabilities */

	struct x86_opengl_frame_buffer_t *draw_buffer;						/* buffer for writing */
	struct x86_opengl_frame_buffer_t *read_buffer;						/* buffer for reading */

	struct x86_opengl_viewport_attributes_t *viewport;						/* viewport attributes */

	struct x86_opengl_matrix_stack_t *modelview_matrix_stack;					/* modelview matrix stack */
	struct x86_opengl_matrix_stack_t *projection_matrix_stack;					/* projection matrix stack */
	struct x86_opengl_matrix_stack_t *texture_matrix_stack[MAX_TEXTURE_UNITS];		/* texture matrix stacks */
	struct x86_opengl_matrix_stack_t *color_matrix_stack;					/* color matrix stack */
	struct x86_opengl_matrix_stack_t *current_matrix_stack;					/* current matrix stack, points to one of above stacks */

};

/*
 * OpenGL global variables
 */

/* OpenGL Context */
struct x86_opengl_context_t *x86_opengl_ctx;

/*
 * OpenGL Initialization
 */

struct x86_opengl_context_capability_t *x86_opengl_context_capability_create(void)
{
	/* Variables */
 	struct x86_opengl_context_capability_t* cap;

 	cap = calloc(1, sizeof(struct x86_opengl_context_capability_t));
	if (!cap)
		fatal("%s: out of memory", __FUNCTION__);

	/* Set up initial value for each capability, initial value for each capability is GL_FALSE, except GL_DITHER and GL_MULTISAMPLE */
	memset(cap, 0, sizeof(struct x86_opengl_context_capability_t));
	cap->is_dither = GL_TRUE;
	cap->is_multisample = GL_TRUE;

	/* Return */
	return cap;
}

void x86_opengl_context_capability_free(struct x86_opengl_context_capability_t *cap)
{
	free(cap);
}

struct x86_opengl_render_buffer_t *x86_opengl_render_buffer_create(int width, int height)
{
	struct x86_opengl_render_buffer_t *rb;

	/* Allocate */
	rb = calloc(1, sizeof(struct x86_opengl_render_buffer_t));
	if(!rb)
		fatal("%s: out of memory", __FUNCTION__);

	/* Initialize */
	rb->width = width;
	rb->height = height;
	rb->buffer = calloc(1, width * height * sizeof(GLuint));

	/* Return */	
	return rb;
}

void x86_opengl_render_buffer_free(struct x86_opengl_render_buffer_t *rb)
{
	free(rb->buffer);
	free(rb);
}

void x86_opengl_render_buffer_clear(struct x86_opengl_render_buffer_t *rb, int clear_value)
{
	if(rb)
		memset(rb->buffer, clear_value, rb->width * rb->height * sizeof(GLuint));
}

int x86_opengl_render_buffer_resize(struct x86_opengl_render_buffer_t *rb, int width, int height)
{
	/* Invalid size */
	if (width < 1 || height < 1)
		fatal("%s: invalid size (width = %d, height = %d)\n",
			__FUNCTION__, width, height);

	/* If same size, just clear it. */
	if (rb->width == width && rb->height == height)
	{
		/* FIXME, currently set value == 1 */
		x86_opengl_render_buffer_clear(rb, 0);
		return 0;
	}

	x86_opengl_debug("\tBuffer resized, W x H = %d x %d\n", width, height);

	/* Free previous buffer */
	if (rb->buffer)
		free(rb->buffer);

	/* Allocate new buffer */
	rb->buffer = calloc(width * height, sizeof(int));
	if (!rb->buffer)
		fatal("%s: out of memory", __FUNCTION__);

	/* Store new size */
	rb->width = width;
	rb->height = height;

	/* Return */
	return 0;	
}

struct x86_opengl_frame_buffer_t *x86_opengl_frame_buffer_create(int width, int height)
{
	/* Variables */
	int i;
	struct x86_opengl_frame_buffer_t *fb;

	/* Allocate */
	fb = calloc(1, sizeof(struct x86_opengl_frame_buffer_t));
	if(!fb)
		fatal("%s: out of memory", __FUNCTION__);

	/* Initialization */
	fb->width = width;
	fb->height = height;
	for (i = 0; i < COLOR_BUFFER_COUNT; ++i)
	{
		fb->color_buffer[i] = x86_opengl_render_buffer_create(width, height);
	}
	fb->depth_buffer = x86_opengl_render_buffer_create(width, height);
	fb->stencil_buffer = x86_opengl_render_buffer_create(width, height);

	/* Return */
	return fb;
}

void x86_opengl_frame_buffer_free(struct x86_opengl_frame_buffer_t *fb)
{
	int i;
	for (i = 0; i < COLOR_BUFFER_COUNT; ++i)
	{
		x86_opengl_render_buffer_free(fb->color_buffer[i]);
	}
	x86_opengl_render_buffer_free(fb->depth_buffer);
	x86_opengl_render_buffer_free(fb->stencil_buffer);

	free(fb);
}

void x86_opengl_frame_buffer_clear(struct x86_opengl_frame_buffer_t *fb, GLbitfield mask)
{
	int i;
	int clear_value;

	/* Get current set value */
	/* FIXME */
	clear_value = 0;
	/* Clear buffer */
	if (fb)
		/* Clear buffers */
		if (mask & ~(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_ACCUM_BUFFER_BIT))
			x86_opengl_debug("\tInvalid mask!\n");

		if ((mask & GL_COLOR_BUFFER_BIT) == GL_COLOR_BUFFER_BIT) 
		{
			x86_opengl_debug("\tColor buffer cleared to %d\n", clear_value);
	    		for (i = 0; i < COLOR_BUFFER_COUNT; ++i)
				x86_opengl_render_buffer_clear(fb->color_buffer[i], clear_value);
	  	}

		if ((mask & GL_DEPTH_BUFFER_BIT) == GL_DEPTH_BUFFER_BIT) 
		{
			x86_opengl_debug("\tDepth buffer cleared to %d\n", clear_value);
	    		x86_opengl_render_buffer_clear(fb->depth_buffer, clear_value);
		}

		if ((mask & GL_STENCIL_BUFFER_BIT) == GL_STENCIL_BUFFER_BIT) {
			x86_opengl_debug("\tStencil buffer cleared to %d\n", clear_value);
	    		x86_opengl_render_buffer_clear(fb->stencil_buffer, clear_value);
		}
	
}

int x86_opengl_frame_buffer_resize(struct x86_opengl_frame_buffer_t *fb, int width, int height)
{
	int i;
	/* Invalid size */
	if (width < 1 || height < 1)
		fatal("%s: invalid size (width = %d, height = %d)\n",
			__FUNCTION__, width, height);

	/* If same size, just clear it. */
	if (fb->width == width && fb->height == height)
	{
		/* FIXME */
		x86_opengl_frame_buffer_clear(fb, 0);
		return 0;
	}	

	/* Resize buffers */
	for (i = 0; i < COLOR_BUFFER_COUNT; ++i)
	{
		x86_opengl_render_buffer_resize(fb->color_buffer[i], width, height);
	}
	x86_opengl_render_buffer_resize(fb->depth_buffer, width, height);
	x86_opengl_render_buffer_resize(fb->stencil_buffer, width, height);

	/* Store new size */
	fb->width = width;
	fb->height = height;

	/* Return */
	return 0;
}

struct x86_opengl_viewport_attributes_t *x86_opengl_viewport_attributes_create(void)
{
	int width;
	int height;
	
	/* Variables */
	struct x86_opengl_viewport_attributes_t *vpt;

	/* Allocate */
	vpt = calloc(1, sizeof(struct x86_opengl_viewport_attributes_t));
	if(!vpt)
		fatal("%s: out of memory", __FUNCTION__);


	/* Initialize */
	width = 0;  // FIXME
	height = 0;  // FIXME

	vpt->x = 0;
	vpt->y = 0;
	vpt->width = width;
	vpt->height = height;

	/* Return */	
	return vpt;
}

void x86_opengl_viewport_free(struct x86_opengl_viewport_attributes_t *vpt)
{
	free(vpt);
}

struct x86_opengl_matrix_t *x86_opengl_matrix_create(enum x86_opengl_matrix_mode_t mode)
{
	struct x86_opengl_matrix_t *mtx;

	/* Allocate */
	mtx = calloc(1, sizeof(struct x86_opengl_matrix_t));
	if(!mtx)
		fatal("%s: out of memory", __FUNCTION__);

	/* Initialize */
	mtx->matrix_mode = mode;
	mtx->matrix = calloc(1, 4*4*sizeof(GLfloat));	/* 4x4 matrix */
	switch(mode)
	{
		case MATRIX_IDENTITY:
		{
			memcpy( mtx->matrix, Identity, sizeof(Identity));
			break;
		}
		default:
			break;
	}

	/* Return */	
	return mtx;
}

void x86_opengl_matrix_free(struct x86_opengl_matrix_t *mtx)
{
	free(mtx->matrix);
	free(mtx);
}

#define A(row,col)  a[(col<<2)+row]
#define B(row,col)  b[(col<<2)+row]
#define P(row,col)  product[(col<<2)+row]

static void x86_opengl_matrix_matmul4( GLfloat *product, const GLfloat *a, const GLfloat *b )
{
	GLint i;
	for (i = 0; i < 4; i++)
	{
		const GLfloat ai0=A(i,0),  ai1=A(i,1),  ai2=A(i,2),  ai3=A(i,3);
		P(i,0) = ai0 * B(0,0) + ai1 * B(1,0) + ai2 * B(2,0) + ai3 * B(3,0);
		P(i,1) = ai0 * B(0,1) + ai1 * B(1,1) + ai2 * B(2,1) + ai3 * B(3,1);
		P(i,2) = ai0 * B(0,2) + ai1 * B(1,2) + ai2 * B(2,2) + ai3 * B(3,2);
		P(i,3) = ai0 * B(0,3) + ai1 * B(1,3) + ai2 * B(2,3) + ai3 * B(3,3);
	}
}

#undef A
#undef B
#undef P

void x86_opengl_matrix_mul_matrix(struct x86_opengl_matrix_t *dst_mtx, struct x86_opengl_matrix_t *mtx_a, struct x86_opengl_matrix_t *mtx_b)
{
	x86_opengl_matrix_matmul4(dst_mtx->matrix, mtx_a->matrix, mtx_b->matrix);
}

struct x86_opengl_matrix_stack_t *x86_opengl_matrix_stack_create(GLenum mode)
{
	struct x86_opengl_matrix_stack_t *stack;
	struct x86_opengl_matrix_t *mtx;

	/* Allocate */
	stack = calloc(1, sizeof(struct x86_opengl_matrix_stack_t));
	if(!stack)
		fatal("%s: out of memory", __FUNCTION__);

	mtx = x86_opengl_matrix_create(MATRIX_GENERAL);

	/* Initialize */
	stack->stack = list_create();
	list_add(stack->stack, mtx);
	stack->depth = 0;

	switch (mode)
	{

	case GL_MODELVIEW:
	{
		stack->max_depth = MAX_MODELVIEW_STACK_DEPTH;
		break;
	}

	case GL_PROJECTION:
	{
		stack->max_depth = MAX_PROJECTION_STACK_DEPTH;
		break;
	}

	case GL_TEXTURE:
	{
		stack->max_depth = MAX_TEXTURE_STACK_DEPTH;
		break;
	}

	case GL_COLOR:
	{
		stack->max_depth = MAX_COLOR_STACK_DEPTH;
		break;
	}

	default:
		break;
	} 

	/* Return */	
	return stack;
}

void x86_opengl_matrix_stack_free(struct x86_opengl_matrix_stack_t *mtx_stack)
{
	/* Free matrices in the list */
	while (list_count(mtx_stack->stack))
		x86_opengl_matrix_free(list_remove_at(mtx_stack->stack, 0));
	/* Free list */
	list_free(mtx_stack->stack);
	/* Free stack */
	free(mtx_stack);
}

int x86_opengl_matrix_stack_push(struct x86_opengl_matrix_stack_t *mtx_stack, void *mtx)
{
	if (mtx_stack->depth == mtx_stack->max_depth)
		fatal("Stack overflow, max depth = %d\n", mtx_stack->max_depth);
	x86_opengl_debug("\tpush: curr_depth = %d, max_depth = %d\n", 
		mtx_stack->depth, mtx_stack->max_depth);
	mtx_stack->depth += 1;
	list_push(mtx_stack->stack, mtx);
	return 0;
}

struct x86_opengl_matrix_t *x86_opengl_matrix_stack_pop(struct x86_opengl_matrix_stack_t *mtx_stack)
{
	/* Variables */
	struct x86_opengl_matrix_t *mtx;

	/* Pop from stack */
	if (mtx_stack->depth == 0 )
		fatal("Stack underflow, max depth = %d\n", mtx_stack->max_depth);
	x86_opengl_debug("\tpop: curr_depth = %d, max_depth = %d\n", 
		mtx_stack->depth, mtx_stack->max_depth);

	mtx_stack->depth -= 1;
	mtx = list_pop(mtx_stack->stack);
	if (mtx == NULL)
		fatal("Empty stack!\n");
	x86_opengl_matrix_free(mtx);

	/* Return */
	return mtx;
}

struct x86_opengl_matrix_t *x86_opengl_matrix_stack_get_current_matrix(struct x86_opengl_context_t *ctx)
{
	/* Variables */
	struct x86_opengl_matrix_t *mtx;

	/* Get current matrix */
	mtx = list_get(ctx->current_matrix_stack->stack, ctx->current_matrix_stack->depth);

	/* Return */
	return mtx;
}

struct x86_opengl_context_t *x86_opengl_context_create(void)
{
	/* Variables */
	int width;
	int height;
	int i;

	/* Allocate */
	struct x86_opengl_context_t *ctx;
	ctx = calloc(1, sizeof(struct x86_opengl_context_t));
	if(!ctx)
		fatal("%s: out of memory", __FUNCTION__);

	/* Initialize frame buffers */
	width = 0;  // FIXME
	height = 0;  // FIXME
	ctx->draw_buffer = x86_opengl_frame_buffer_create(width, height);
	ctx->read_buffer = x86_opengl_frame_buffer_create(width, height);
	
	/* Initialize context capabilities */
	ctx->context_cap = x86_opengl_context_capability_create();

	/* Initialize viewport */
	ctx->viewport = x86_opengl_viewport_attributes_create();

	/* Initialize matrix stack */
	ctx->modelview_matrix_stack = x86_opengl_matrix_stack_create(GL_MODELVIEW);
	ctx->projection_matrix_stack = x86_opengl_matrix_stack_create(GL_PROJECTION);
	for (i = 0; i < MAX_TEXTURE_STACK_DEPTH; i++)
	{
		ctx->texture_matrix_stack[i] = x86_opengl_matrix_stack_create(GL_TEXTURE);
	}
	ctx->color_matrix_stack = x86_opengl_matrix_stack_create(GL_COLOR);
	/* FIXME: which one is the default current stack ? */
	ctx->current_matrix_stack = ctx->modelview_matrix_stack;

	/* Return */
	return ctx;
}

void x86_opengl_context_free(struct x86_opengl_context_t *ctx)
{
	/* Variables */
	int i;

	/* Free context capabilities*/
	x86_opengl_context_capability_free(ctx->context_cap);

	/* Free framebuffers */
	x86_opengl_frame_buffer_free(ctx->draw_buffer);
	x86_opengl_frame_buffer_free(ctx->read_buffer);

	/* Free viewport */
	x86_opengl_viewport_free(ctx->viewport);

	/* Free matrix stacks */
	x86_opengl_matrix_stack_free(ctx->modelview_matrix_stack);
	x86_opengl_matrix_stack_free(ctx->projection_matrix_stack);
	for (i = 0; i < MAX_TEXTURE_STACK_DEPTH; i++)
	{
		x86_opengl_matrix_stack_free(ctx->texture_matrix_stack[i]);	
	}
	x86_opengl_matrix_stack_free(ctx->color_matrix_stack);

	free(ctx);
}

void x86_opengl_init(void)
{
	x86_opengl_ctx = x86_opengl_context_create();
}


void x86_opengl_done(void)
{
	if (x86_opengl_ctx != NULL)
		x86_opengl_context_free(x86_opengl_ctx);
}


int x86_opengl_call(void)
{
	/* Variables */
	int code;
	int ret;

	/* Function code */
	code = x86_isa_regs->ebx;
	if (code <= x86_opengl_call_invalid || code >= x86_opengl_call_count)
		fatal("%s: invalid OpenGL function (code %d).\n%s",
			__FUNCTION__, code, err_x86_opengl_code);

	/* Debug */
	x86_opengl_debug("OpenGL runtime call '%s' (code %d)\n",
		x86_opengl_call_name[code], code);

	/* Call OPENGL function */
	assert(x86_opengl_func_table[code]);
	ret = x86_opengl_func_table[code]();

	/* Return value */
	return ret;
}

/*
 * OpenGL call #1 - glDrawBuffer
 *
 * glDrawBuffer - specify which color buffers are to be drawn into
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glDrawBuffer(void)
{
	/* Variables */
	unsigned int mode_ptr;

	/* Read arguments */
	mode_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tmode_ptr=0x%x\n", mode_ptr);

	GLenum mode;

	mem_read(x86_isa_mem, mode_ptr, sizeof(GLenum), &mode);

	/* Set color buffers */
	fatal("Not implemented yet!\n");

	/* Return success */
	return 0;
}


/*
 * OpenGL call #2 - glReadBuffer
 *
 * glReadBuffer - select a color buffer source for pixels
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glReadBuffer(void)
{
	/* Variables */
	unsigned int mode_ptr;

	/* Read arguments */
	mode_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tmode_ptr=0x%x\n", mode_ptr);

	GLenum mode;
	mem_read(x86_isa_mem, mode_ptr, sizeof(GLenum), &mode);

	/* Set color buffers */
	fatal("Not implemented yet!\n");

	/* Return success */
	return 0;
}
/*
 * OpenGL call #3 - glEnable
 *
 * glEnable - enable server-side GL capabilities
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glEnable(void)
{
	/* Variables */
	unsigned int cap_ptr;

	/* Read arguments */
	cap_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tcap_ptr=0x%x\n", cap_ptr);

	GLenum cap;

	mem_read(x86_isa_mem, cap_ptr, sizeof(GLenum), &cap);

	switch(cap)
	{

	case GL_ALPHA_TEST:

		{
			x86_opengl_ctx->context_cap->is_alpha_test = GL_TRUE;
			x86_opengl_debug("\tGL_ALPHA_TEST enabled!\n");
			break;
		}

	case GL_AUTO_NORMAL:

		{
			x86_opengl_ctx->context_cap->is_auto_normal = GL_TRUE;
			x86_opengl_debug("\tGL_AUTO_NORMAL enabled!\n");
			break;
		}

	case GL_BLEND:

		{
			x86_opengl_ctx->context_cap->is_blend = GL_TRUE;
			x86_opengl_debug("\tGL_BLEND enabled!\n");
			break;
		}

	case GL_CLIP_PLANE0:

		{
			x86_opengl_ctx->context_cap->is_clip_plane0 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE0 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE1:

		{
			x86_opengl_ctx->context_cap->is_clip_plane1 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE1 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE2:

		{
			x86_opengl_ctx->context_cap->is_clip_plane2 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE2 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE3:

		{
			x86_opengl_ctx->context_cap->is_clip_plane3 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE3 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE4:

		{
			x86_opengl_ctx->context_cap->is_clip_plane4 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE4 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE5:

		{
			x86_opengl_ctx->context_cap->is_clip_plane5 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE5 enabled!\n");
			break;
		}

	case GL_COLOR_LOGIC_OP:

		{
			x86_opengl_ctx->context_cap->is_color_logic_op = GL_TRUE;
			x86_opengl_debug("\tGL_COLOR_LOGIC_OP enabled!\n");
			break;
		}

	case GL_COLOR_MATERIAL:

		{
			x86_opengl_ctx->context_cap->is_color_material = GL_TRUE;
			x86_opengl_debug("\tGL_COLOR_MATERIAL enabled!\n");
			break;
		}

	case GL_COLOR_SUM:

		{
			x86_opengl_ctx->context_cap->is_color_sum = GL_TRUE;
			x86_opengl_debug("\tGL_COLOR_SUM enabled!\n");
			break;
		}

	case GL_COLOR_TABLE:

		{
			x86_opengl_ctx->context_cap->is_color_table = GL_TRUE;
			x86_opengl_debug("\tGL_COLOR_TABLE enabled!\n");
			break;
		}

	case GL_CONVOLUTION_1D:

		{
			x86_opengl_ctx->context_cap->is_convolution_1d = GL_TRUE;
			x86_opengl_debug("\tGL_CONVOLUTION_1D enabled!\n");
			break;
		}

	case GL_CONVOLUTION_2D:

		{
			x86_opengl_ctx->context_cap->is_convolution_2d = GL_TRUE;
			x86_opengl_debug("\tGL_CONVOLUTION_2D enabled!\n");
			break;
		}

	case GL_CULL_FACE:

		{
			x86_opengl_ctx->context_cap->is_cull_face = GL_TRUE;
			x86_opengl_debug("\tGL_CULL_FACE enabled!\n");
			break;
		}

	case GL_DEPTH_TEST:

		{
			x86_opengl_ctx->context_cap->is_depth_test = GL_TRUE;
			x86_opengl_debug("\tGL_DEPTH_TEST enabled!\n");
			break;
		}

	case GL_DITHER:

		{
			x86_opengl_ctx->context_cap->is_dither = GL_TRUE;
			x86_opengl_debug("\tGL_DITHER enabled!\n");
			break;
		}

	case GL_FOG:

		{
			x86_opengl_ctx->context_cap->is_fog = GL_TRUE;
			x86_opengl_debug("\tGL_FOG enabled!\n");
			break;
		}

	case GL_HISTOGRAM:

		{
			x86_opengl_ctx->context_cap->is_histogram = GL_TRUE;
			x86_opengl_debug("\tGL_HISTOGRAM enabled!\n");
			break;
		}

	case GL_INDEX_LOGIC_OP:

		{
			x86_opengl_ctx->context_cap->is_index_logic_op = GL_TRUE;
			x86_opengl_debug("\tGL_INDEX_LOGIC_OP enabled!\n");
			break;
		}

	case GL_LIGHT0:

		{
			x86_opengl_ctx->context_cap->is_light0 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT0 enabled!\n");
			break;
		}

	case GL_LIGHT1:

		{
			x86_opengl_ctx->context_cap->is_light1 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT1 enabled!\n");
			break;
		}

	case GL_LIGHT2:

		{
			x86_opengl_ctx->context_cap->is_light2 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT2 enabled!\n");
			break;
		}

	case GL_LIGHT3:

		{
			x86_opengl_ctx->context_cap->is_light3 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT3 enabled!\n");
			break;
		}

	case GL_LIGHT4:

		{
			x86_opengl_ctx->context_cap->is_light4 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT4 enabled!\n");
			break;
		}

	case GL_LIGHT5:

		{
			x86_opengl_ctx->context_cap->is_light5 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT5 enabled!\n");
			break;
		}

	case GL_LIGHT6:

		{
			x86_opengl_ctx->context_cap->is_light6 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT6 enabled!\n");
			break;
		}

	case GL_LIGHT7:

		{
			x86_opengl_ctx->context_cap->is_light7 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT7 enabled!\n");
			break;
		}

	case GL_LIGHTING:

		{
			x86_opengl_ctx->context_cap->is_lighting = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHTING enabled!\n");
			break;
		}

	case GL_LINE_SMOOTH:

		{
			x86_opengl_ctx->context_cap->is_line_smooth = GL_TRUE;
			x86_opengl_debug("\tGL_LINE_SMOOTH enabled!\n");
			break;
		}

	case GL_LINE_STIPPLE:

		{
			x86_opengl_ctx->context_cap->is_line_stipple = GL_TRUE;
			x86_opengl_debug("\tGL_LINE_STIPPLE enabled!\n");
			break;
		}

	case GL_MAP1_COLOR_4:

		{
			x86_opengl_ctx->context_cap->is_map1_color_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_COLOR_4 enabled!\n");
			break;
		}

	case GL_MAP1_INDEX:

		{
			x86_opengl_ctx->context_cap->is_map1_index = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_INDEX enabled!\n");
			break;
		}

	case GL_MAP1_NORMAL:

		{
			x86_opengl_ctx->context_cap->is_map1_normal = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_NORMAL enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_1:

		{
			x86_opengl_ctx->context_cap->is_map1_texture_coord_1 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_TEXTURE_COORD_1 enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_2:

		{
			x86_opengl_ctx->context_cap->is_map1_texture_coord_2 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_TEXTURE_COORD_2 enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_3:

		{
			x86_opengl_ctx->context_cap->is_map1_texture_coord_3 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_TEXTURE_COORD_3 enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_4:

		{
			x86_opengl_ctx->context_cap->is_map1_texture_coord_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_TEXTURE_COORD_4 enabled!\n");
			break;
		}

	case GL_MAP1_VERTEX_3:

		{
			x86_opengl_ctx->context_cap->is_map1_vertex_3 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_VERTEX_3 enabled!\n");
			break;
		}

	case GL_MAP1_VERTEX_4:

		{
			x86_opengl_ctx->context_cap->is_map1_vertex_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_VERTEX_4 enabled!\n");
			break;
		}

	case GL_MAP2_COLOR_4:

		{
			x86_opengl_ctx->context_cap->is_map2_color_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_COLOR_4 enabled!\n");
			break;
		}

	case GL_MAP2_INDEX:

		{
			x86_opengl_ctx->context_cap->is_map2_index = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_INDEX enabled!\n");
			break;
		}

	case GL_MAP2_NORMAL:

		{
			x86_opengl_ctx->context_cap->is_map2_normal = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_NORMAL enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_1:

		{
			x86_opengl_ctx->context_cap->is_map2_texture_coord_1 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_TEXTURE_COORD_1 enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_2:

		{
			x86_opengl_ctx->context_cap->is_map2_texture_coord_2 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_TEXTURE_COORD_2 enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_3:

		{
			x86_opengl_ctx->context_cap->is_map2_texture_coord_3 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_TEXTURE_COORD_3 enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_4:

		{
			x86_opengl_ctx->context_cap->is_map2_texture_coord_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_TEXTURE_COORD_4 enabled!\n");
			break;
		}

	case GL_MAP2_VERTEX_3:

		{
			x86_opengl_ctx->context_cap->is_map2_vertex_3 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_VERTEX_3 enabled!\n");
			break;
		}

	case GL_MAP2_VERTEX_4:

		{
			x86_opengl_ctx->context_cap->is_map2_vertex_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_VERTEX_4 enabled!\n");
			break;
		}

	case GL_MINMAX:

		{
			x86_opengl_ctx->context_cap->is_minmax = GL_TRUE;
			x86_opengl_debug("\tGL_MINMAX enabled!\n");
			break;
		}

	case GL_MULTISAMPLE:

		{
			x86_opengl_ctx->context_cap->is_multisample = GL_TRUE;
			x86_opengl_debug("\tGL_MULTISAMPLE enabled!\n");
			break;
		}

	case GL_NORMALIZE:

		{
			x86_opengl_ctx->context_cap->is_normalize = GL_TRUE;
			x86_opengl_debug("\tGL_NORMALIZE enabled!\n");
			break;
		}

	case GL_POINT_SMOOTH:

		{
			x86_opengl_ctx->context_cap->is_point_smooth = GL_TRUE;
			x86_opengl_debug("\tGL_POINT_SMOOTH enabled!\n");
			break;
		}

	case GL_POINT_SPRITE:

		{
			x86_opengl_ctx->context_cap->is_point_sprite = GL_TRUE;
			x86_opengl_debug("\tGL_POINT_SPRITE enabled!\n");
			break;
		}

	case GL_POLYGON_OFFSET_FILL:

		{
			x86_opengl_ctx->context_cap->is_polygon_offset_fill = GL_TRUE;
			x86_opengl_debug("\tGL_POLYGON_OFFSET_FILL enabled!\n");
			break;
		}

	case GL_POLYGON_OFFSET_LINE:

		{
			x86_opengl_ctx->context_cap->is_polygon_offset_line = GL_TRUE;
			x86_opengl_debug("\tGL_POLYGON_OFFSET_LINE enabled!\n");
			break;
		}

	case GL_POLYGON_OFFSET_POINT:

		{
			x86_opengl_ctx->context_cap->is_polygon_offset_point = GL_TRUE;
			x86_opengl_debug("\tGL_POLYGON_OFFSET_POINT enabled!\n");
			break;
		}

	case GL_POLYGON_SMOOTH:

		{
			x86_opengl_ctx->context_cap->is_polygon_smooth = GL_TRUE;
			x86_opengl_debug("\tGL_POLYGON_SMOOTH enabled!\n");
			break;
		}

	case GL_POLYGON_STIPPLE:

		{
			x86_opengl_ctx->context_cap->is_polygon_stipple = GL_TRUE;
			x86_opengl_debug("\tGL_POLYGON_STIPPLE enabled!\n");
			break;
		}

	case GL_POST_COLOR_MATRIX_COLOR_TABLE:

		{
			x86_opengl_ctx->context_cap->is_post_color_matrix_color_table = GL_TRUE;
			x86_opengl_debug("\tGL_POST_COLOR_MATRIX_COLOR_TABLE enabled!\n");
			break;
		}

	case GL_POST_CONVOLUTION_COLOR_TABLE:

		{
			x86_opengl_ctx->context_cap->is_post_convolution_color_table = GL_TRUE;
			x86_opengl_debug("\tGL_POST_CONVOLUTION_COLOR_TABLE enabled!\n");
			break;
		}

	case GL_RESCALE_NORMAL:

		{
			x86_opengl_ctx->context_cap->is_rescale_normal = GL_TRUE;
			x86_opengl_debug("\tGL_RESCALE_NORMAL enabled!\n");
			break;
		}

	case GL_SAMPLE_ALPHA_TO_COVERAGE:

		{
			x86_opengl_ctx->context_cap->is_sample_alpha_to_coverage = GL_TRUE;
			x86_opengl_debug("\tGL_SAMPLE_ALPHA_TO_COVERAGE enabled!\n");
			break;
		}

	case GL_SAMPLE_ALPHA_TO_ONE:

		{
			x86_opengl_ctx->context_cap->is_sample_alpha_to_one = GL_TRUE;
			x86_opengl_debug("\tGL_SAMPLE_ALPHA_TO_ONE enabled!\n");
			break;
		}

	case GL_SAMPLE_COVERAGE:

		{
			x86_opengl_ctx->context_cap->is_sample_coverage = GL_TRUE;
			x86_opengl_debug("\tGL_SAMPLE_COVERAGE enabled!\n");
			break;
		}

	case GL_SEPARABLE_2D:

		{
			x86_opengl_ctx->context_cap->is_separable_2d = GL_TRUE;
			x86_opengl_debug("\tGL_SEPARABLE_2D enabled!\n");
			break;
		}

	case GL_SCISSOR_TEST:

		{
			x86_opengl_ctx->context_cap->is_scissor_test = GL_TRUE;
			x86_opengl_debug("\tGL_SCISSOR_TEST enabled!\n");
			break;
		}

	case GL_STENCIL_TEST:

		{
			x86_opengl_ctx->context_cap->is_stencil_test = GL_TRUE;
			x86_opengl_debug("\tGL_STENCIL_TEST enabled!\n");
			break;
		}

	case GL_TEXTURE_1D:

		{
			x86_opengl_ctx->context_cap->is_texture_1d = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_1D enabled!\n");
			break;
		}

	case GL_TEXTURE_2D:

		{
			x86_opengl_ctx->context_cap->is_texture_2d = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_2D enabled!\n");
			break;
		}

	case GL_TEXTURE_3D:

		{
			x86_opengl_ctx->context_cap->is_texture_3d = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_3D enabled!\n");
			break;
		}

	case GL_TEXTURE_CUBE_MAP:

		{
			x86_opengl_ctx->context_cap->is_texture_cube_map = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_CUBE_MAP enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_Q:

		{
			x86_opengl_ctx->context_cap->is_texture_gen_q = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_GEN_Q enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_R:

		{
			x86_opengl_ctx->context_cap->is_texture_gen_r = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_GEN_R enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_S:

		{
			x86_opengl_ctx->context_cap->is_texture_gen_s = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_GEN_S enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_T:

		{
			x86_opengl_ctx->context_cap->is_texture_gen_t = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_GEN_T enabled!\n");
			break;
		}

	case GL_VERTEX_PROGRAM_POINT_SIZE:

		{
			x86_opengl_ctx->context_cap->is_vertex_program_point_size = GL_TRUE;
			x86_opengl_debug("\tGL_VERTEX_PROGRAM_POINT_SIZE enabled!\n");
			break;
		}

	case GL_VERTEX_PROGRAM_TWO_SIDE:

		{
			x86_opengl_ctx->context_cap->is_vertex_program_two_side = GL_TRUE;
			x86_opengl_debug("\tGL_VERTEX_PROGRAM_TWO_SIDE enabled!\n");
			break;
		}

	default:
		break;
	}

	/* Return success */
	return 0;
}

/*
 * OpenGL call #4 - glViewport
 *
 * glViewport - set the viewport
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glViewport(void)
{
	/* Variables */
	unsigned int args_ptr;
	unsigned int argc_ptr;

	int func_args[X86_OPENGL_MAX_ARGS];
	int func_argc;

	/* Read arguments */
	args_ptr = x86_isa_regs->ecx;
	argc_ptr = x86_isa_regs->edx;

	x86_opengl_debug("\targs_ptr=0x%x\n", args_ptr);
	x86_opengl_debug("\targc_ptr=0x%x\n", argc_ptr);

	/* Get function info */
	mem_read(x86_isa_mem, argc_ptr, sizeof(int), &func_argc);
	mem_read(x86_isa_mem, args_ptr, func_argc * 4, func_args);
	x86_opengl_ctx->viewport->x = func_args[0];
	x86_opengl_ctx->viewport->y = func_args[1];
	x86_opengl_ctx->viewport->width = func_args[2];
	x86_opengl_ctx->viewport->height = func_args[3];

	/* Initialize */
	x86_opengl_debug("\tviewport: x=%d, y=%d, width=%d, height=%d\n",
				x86_opengl_ctx->viewport->x, x86_opengl_ctx->viewport->y, 
				x86_opengl_ctx->viewport->width, x86_opengl_ctx->viewport->height);

	/* Update frame buffer */
	/* FIXME: Viewport size != frame buffer size, it only selects a part of frame buffer */
	x86_opengl_frame_buffer_resize(x86_opengl_ctx->draw_buffer, 
		x86_opengl_ctx->viewport->width, x86_opengl_ctx->viewport->height);
	x86_opengl_frame_buffer_resize(x86_opengl_ctx->read_buffer, 
		x86_opengl_ctx->viewport->width, x86_opengl_ctx->viewport->height);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #5 - glMatrixMode
 *
 * glMatrixMode - specify which matrix is the current matrix
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glMatrixMode(void)
{
	/* Variables */
	unsigned int mtx_mode_ptr;

	/* Read arguments */
	mtx_mode_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tmtx_mode_ptr=0x%x\n", mtx_mode_ptr);

	GLenum mtx_mod;
	mem_read(x86_isa_mem, mtx_mode_ptr, sizeof(mtx_mod), &mtx_mod);

	/* Set up current matrix */
	switch(mtx_mod)
	{
		case	GL_MODELVIEW:
		{
			x86_opengl_ctx->current_matrix_stack = x86_opengl_ctx->modelview_matrix_stack;
			break;
		}
			
		case	GL_PROJECTION:
		{
			x86_opengl_ctx->current_matrix_stack = x86_opengl_ctx->projection_matrix_stack;
			break;
		}

		case	GL_TEXTURE:
		{
			/* FIXME: choose which one? */
			x86_opengl_ctx->current_matrix_stack = x86_opengl_ctx->texture_matrix_stack[0];
			break;
		}

		case	GL_COLOR:
		{
			x86_opengl_ctx->current_matrix_stack = x86_opengl_ctx->color_matrix_stack;
			break;
		}
		default:
			break;
	}

	/* Return */
	return 0;	
}

/*
 * OpenGL call #6 - glLoadIdentity
 *
 * glLoadIdentity - replace the current matrix with the identity matrix
 *		       the current matrix in any mode is the matrix on the top of the stack for that mode.
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glLoadIdentity(void)
{
	/* Pop from current stack and free the matrix */
	if (x86_opengl_ctx->current_matrix_stack->depth > 0)
		x86_opengl_matrix_stack_pop(x86_opengl_ctx->current_matrix_stack);

	/* Push identity matrix to the current matrix stack */
	struct x86_opengl_matrix_t *mtx = x86_opengl_matrix_create(MATRIX_IDENTITY);
	x86_opengl_matrix_stack_push(x86_opengl_ctx->current_matrix_stack, mtx);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #7 - glOrtho
 *
 * glOrtho - multiply the current matrix with an orthographic matrix
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glOrtho(void)
{
	/* Variables */
	unsigned int args_ptr;
	unsigned int argc_ptr;

	GLdouble func_args[X86_OPENGL_MAX_ARGS];
	int func_argc;
	int i;
	int j;

	/* Read arguments */
	args_ptr = x86_isa_regs->ecx;
	argc_ptr = x86_isa_regs->edx;

	x86_opengl_debug("\targs_ptr=0x%x\n", args_ptr);
	x86_opengl_debug("\targc_ptr=0x%x\n", argc_ptr);

	/* Get function info */
	mem_read(x86_isa_mem, argc_ptr, sizeof(int), &func_argc);
	mem_read(x86_isa_mem, args_ptr, func_argc * sizeof(GLdouble), func_args);
	for (i = 0; i < func_argc; i++)
		x86_opengl_debug("\t\targs[%d] = %f (0x%f)\n",
			i, func_args[i], func_args[i]);

	/* Current matrix multiplies orthographic matrix */
	struct x86_opengl_matrix_t *mtx_ortho;
	struct x86_opengl_matrix_t *mtx_curr;

	/* Calculate orthographic matrix */
	GLfloat ortho_matrix[16];

	GLfloat left = func_args[0];
	GLfloat right = func_args[1];
	GLfloat bottom = func_args[2];
	GLfloat top = func_args[3];
	GLfloat nearval = func_args[4];
	GLfloat farval = func_args[5];

	#define M(row,col)  ortho_matrix[col*4+row]
	M(0,0) = 2.0F / (right-left);
	M(0,1) = 0.0F;
	M(0,2) = 0.0F;
	M(0,3) = -(right+left) / (right-left);

	M(1,0) = 0.0F;
	M(1,1) = 2.0F / (top-bottom);
	M(1,2) = 0.0F;
	M(1,3) = -(top+bottom) / (top-bottom);

	M(2,0) = 0.0F;
	M(2,1) = 0.0F;
	M(2,2) = -2.0F / (farval-nearval);
	M(2,3) = -(farval+nearval) / (farval-nearval);

	M(3,0) = 0.0F;
	M(3,1) = 0.0F;
	M(3,2) = 0.0F;
	M(3,3) = 1.0F;
	#undef M

	/* Initialize orthographic matrix */
	mtx_ortho = x86_opengl_matrix_create(MATRIX_GENERAL);
	memcpy(mtx_ortho->matrix, ortho_matrix, 16*sizeof(GLfloat));

	x86_opengl_debug("\t\tOrtho:\n");
	for (i = 0; i < 4; ++i)
	{
		x86_opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			x86_opengl_debug("%f\t", mtx_ortho->matrix[i*4+j]);
		}
		x86_opengl_debug("\n");
	}

	mtx_curr = x86_opengl_matrix_stack_get_current_matrix(x86_opengl_ctx);
	x86_opengl_debug("\t\tCurr:\n");
	for (i = 0; i < 4; ++i)
	{
		x86_opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			x86_opengl_debug("%f\t", mtx_curr->matrix[i*4+j]);
		}
		x86_opengl_debug("\n");
	}

	x86_opengl_matrix_mul_matrix(mtx_curr, mtx_curr, mtx_ortho);
	x86_opengl_debug("\t\tCurr mul Ortho:\n");
	for (i = 0; i < 4; ++i)
	{
		x86_opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			x86_opengl_debug("%f\t", mtx_curr->matrix[i*4+j]);
		}
		x86_opengl_debug("\n");
	}

	/* Free */
	x86_opengl_matrix_free(mtx_ortho);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #8 - glClear
 *
 * glClear - clear buffers to present values
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glClear(void)
{
	unsigned int mask_ptr;
	GLbitfield mask;

	/* Read arguments */
	mask_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tmask_ptr=0x%x\n", mask_ptr);
	mem_read(x86_isa_mem, mask_ptr, sizeof(GLbitfield), &mask);

	/* Clear */
	x86_opengl_frame_buffer_clear(x86_opengl_ctx->draw_buffer, mask);
	x86_opengl_frame_buffer_clear(x86_opengl_ctx->read_buffer, mask);

	/* Return */
	return 0;	
}

