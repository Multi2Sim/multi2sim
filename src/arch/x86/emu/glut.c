/*
 *  Multi2Sim
 *  Copyright (C) 2011  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <x86-emu.h>
#include <mem-system.h>

#include <GL/glut.h>

static char *err_x86_glut_code =
	"\tAn invalid function code was generated by your application in a GLUT system\n"
	"\tcall. Probably, this means that your application is using an incompatible\n"
	"\tversion of the Multi2Sim GLUT runtime library ('libm2s-glut'). Please\n"
	"\trecompile your application and try again.\n";


/* Debug */
int x86_glut_debug_category;


/*
 * GLUT calls
 */

/* List of GLUT runtime calls */
enum x86_glut_call_t
{
	x86_glut_call_invalid = 0,
#define X86_GLUT_DEFINE_CALL(name, code) x86_glut_call_##name = code,
#include "glut.dat"
#undef X86_GLUT_DEFINE_CALL
	x86_glut_call_count
};


/* List of GLUT runtime call names */
char *x86_glut_call_name[x86_glut_call_count + 1] =
{
	NULL,
#define X86_GLUT_DEFINE_CALL(name, code) #name,
#include "glut.dat"
#undef X86_GLUT_DEFINE_CALL
	NULL
};


/* Forward declarations of GLUT runtime functions */
#define X86_GLUT_DEFINE_CALL(name, code) static int x86_glut_func_##name(void);
#include "glut.dat"
#undef X86_GLUT_DEFINE_CALL


/* List of GLUT runtime functions */
typedef int (*x86_glut_func_t)(void);
static x86_glut_func_t x86_glut_func_table[x86_glut_call_count + 1] =
{
	NULL,
#define X86_GLUT_DEFINE_CALL(name, code) x86_glut_func_##name,
#include "glut.dat"
#undef X86_GLUT_DEFINE_CALL
	NULL
};





/*
 * GLUT global variables
 */

/* Global GLUT mutex and thread */
static pthread_mutex_t x86_glut_mutex;
static pthread_t x86_glut_thread;

/* List of events.
 * The global GLUT mutex should be locked when accessing this list. */
static struct linked_list_t *x86_glut_event_list;




/*
 * GLUT event
 */

enum x86_glut_event_type_t
{
	x86_glut_event_invalid = 0,
	x86_glut_event_display,
	x86_glut_event_overlay_display,
	x86_glut_event_reshape,
	x86_glut_event_keyboard,
	x86_glut_event_mouse,
	x86_glut_event_motion,
	x86_glut_event_passive_motion,
	x86_glut_event_visibility,
	x86_glut_event_entry,
	x86_glut_event_special,
	x86_glut_event_spaceball_motion,
	x86_glut_event_spaceball_rotate,
	x86_glut_event_spaceball_button,
	x86_glut_event_button_box,
	x86_glut_event_dials,
	x86_glut_event_tablet_motion,
	x86_glut_event_tablet_button,
	x86_glut_event_menu_status,
	x86_glut_event_idle,
	x86_glut_event_timer
};

struct x86_glut_event_t
{
	enum x86_glut_event_type_t type;

	union
	{
		struct
		{
			int win;
		} display;

		struct
		{
			int win;
			int width;
			int height;
		} reshape;

		struct
		{
			int win;
		} overlay_display;

		struct
		{
			int win;
			unsigned char key;
			int x;
			int y;
		} keyboard;

		struct
		{
			int win;
			int button;
			int state;
			int x;
			int y;
		} mouse;

		struct
		{
			int win;
			int x;
			int y;
		} motion;

		struct
		{
			int win;
			int state;
		} visibility;

		struct
		{
			int win;
			int state;
		} entry;

		struct
		{
			int win;
			int key;
			int x;
			int y;
		} special;

		struct
		{
			int win;
			int x;
			int y;
			int z;
		} spaceball_motion;

		struct
		{
			int win;
			int x;
			int y;
			int z;
		} spaceball_rotate;

		struct
		{
			int win;
			int button;
			int state;
		} spaceball_button;

		struct
		{
			int win;
			int button;
			int state;
		} button_box;

		struct
		{
			int win;
			int dial;
			int value;
		} dials;

		struct
		{
			int win;
			int x;
			int y;
		} tablet_motion;

		struct
		{
			int win;
			int button;
			int state;
			int x;
			int y;
		} tablet_button;

		struct
		{
			int status;
			int x;
			int y;
		} menu_status;

		struct
		{
			int value;
		} timer;
	} u;
};


struct x86_glut_event_t *x86_glut_event_create(enum x86_glut_event_type_t type)
{
	struct x86_glut_event_t *event;

	/* Allocate */
	event = calloc(1, sizeof(struct x86_glut_event_t));
	if (!event)
		fatal("%s: out of memory", __FUNCTION__);
	
	/* Initialize */
	event->type = type;

	/* Return */
	return event;
}


void x86_glut_event_free(struct x86_glut_event_t *event)
{
	free(event);
}


/* Enqueue an event in the global event list. The list is accessed in a
 * thread-safe fashion by locking the global GLUT mutex. */
void x86_glut_event_enqueue(struct x86_glut_event_t *event)
{
	pthread_mutex_lock(&x86_glut_mutex);
	linked_list_add(x86_glut_event_list, event);
	pthread_mutex_unlock(&x86_glut_mutex);
}


/* Dequeue an event from the global event list head. The list is accessed in a
 * thread-safe fashion by locking the global GLUT mutex. The function returns
 * NULL if there is no event in the queue. */
struct x86_glut_event_t *x86_glut_event_dequeue(void)
{
	struct x86_glut_event_t *event;

	pthread_mutex_lock(&x86_glut_mutex);
	linked_list_head(x86_glut_event_list);
	event = linked_list_get(x86_glut_event_list);
	linked_list_remove(x86_glut_event_list);
	pthread_mutex_unlock(&x86_glut_mutex);

	return event;
}




/*
 * GLUT host callback functions
 */

void x86_glut_display_func(void)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_display);
	event->u.keyboard.win = glutGetWindow();

	x86_glut_event_enqueue(event);
}


void x86_glut_overlay_display_func(void)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_overlay_display);
	event->u.keyboard.win = glutGetWindow();

	x86_glut_event_enqueue(event);
}


void x86_glut_reshape_func(int width, int height)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_reshape);
	event->u.reshape.win = glutGetWindow();
	event->u.reshape.width = width;
	event->u.reshape.height = height;

	x86_glut_event_enqueue(event);
}


void x86_glut_keyboard_func(unsigned char key, int x, int y)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_keyboard);
	event->u.keyboard.win = glutGetWindow();
	event->u.keyboard.key = key;
	event->u.keyboard.x = x;
	event->u.keyboard.y = y;

	x86_glut_event_enqueue(event);
}


void x86_glut_mouse_func(int button, int state, int x, int y)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_mouse);
	event->u.mouse.win = glutGetWindow();
	event->u.mouse.button = button;
	event->u.mouse.state = state;
	event->u.mouse.x = x;
	event->u.mouse.y = y;

	x86_glut_event_enqueue(event);
}


void x86_glut_motion_func(int x, int y)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_motion);
	event->u.motion.win = glutGetWindow();
	event->u.motion.x = x;
	event->u.motion.y = y;

	x86_glut_event_enqueue(event);
}


void x86_glut_passive_motion_func(int x, int y)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_passive_motion);
	event->u.motion.win = glutGetWindow();
	event->u.motion.x = x;
	event->u.motion.y = y;

	x86_glut_event_enqueue(event);
}


void x86_glut_visibility_func(int state)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_visibility);
	event->u.visibility.win = glutGetWindow();
	event->u.visibility.state = state;

	x86_glut_event_enqueue(event);
}


void x86_glut_entry_func(int state)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_entry);
	event->u.entry.win = glutGetWindow();
	event->u.entry.state = state;

	x86_glut_event_enqueue(event);
}


void x86_glut_special_func(int key, int x, int y)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_special);
	event->u.special.win = glutGetWindow();
	event->u.special.key = key;
	event->u.special.x = x;
	event->u.special.y = y;

	x86_glut_event_enqueue(event);
}


void x86_glut_spaceball_motion_func(int x, int y, int z)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_spaceball_motion);
	event->u.spaceball_motion.win = glutGetWindow();
	event->u.spaceball_motion.x = x;
	event->u.spaceball_motion.y = y;
	event->u.spaceball_motion.z = z;

	x86_glut_event_enqueue(event);
}


void x86_glut_spaceball_rotate_func(int x, int y, int z)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_spaceball_rotate);
	event->u.spaceball_rotate.win = glutGetWindow();
	event->u.spaceball_rotate.x = x;
	event->u.spaceball_rotate.y = y;
	event->u.spaceball_rotate.z = z;

	x86_glut_event_enqueue(event);
}


void x86_glut_spaceball_button_func(int button, int state)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_spaceball_button);
	event->u.spaceball_button.win = glutGetWindow();
	event->u.spaceball_button.button = button;
	event->u.spaceball_button.state = state;

	x86_glut_event_enqueue(event);
}


void x86_glut_button_box_func(int button, int state)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_spaceball_button);
	event->u.button_box.win = glutGetWindow();
	event->u.button_box.button = button;
	event->u.button_box.state = state;

	x86_glut_event_enqueue(event);
}


void x86_glut_dials_func(int dial, int value)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_dials);
	event->u.dials.win = glutGetWindow();
	event->u.dials.dial = dial;
	event->u.dials.value = value;

	x86_glut_event_enqueue(event);
}


void x86_glut_tablet_motion_func(int x, int y)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_tablet_motion);
	event->u.tablet_motion.win = glutGetWindow();
	event->u.tablet_motion.x = x;
	event->u.tablet_motion.y = y;

	x86_glut_event_enqueue(event);
}


void x86_glut_tablet_button_func(int button, int state, int x, int y)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_tablet_button);
	event->u.tablet_button.win = glutGetWindow();
	event->u.tablet_button.button = button;
	event->u.tablet_button.state = state;
	event->u.tablet_button.x = x;
	event->u.tablet_button.y = y;

	x86_glut_event_enqueue(event);
}


void x86_glut_tablet_menu_status(int status, int x, int y)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_menu_status);
	event->u.menu_status.status = status;
	event->u.menu_status.x = x;
	event->u.menu_status.y = y;

	x86_glut_event_enqueue(event);
}


void x86_glut_timer(int value)
{
	struct x86_glut_event_t *event;

	event = x86_glut_event_create(x86_glut_event_timer);
	event->u.timer.value = value;

	x86_glut_event_enqueue(event);
}






/*
 * GLUT global functions
 */

void x86_glut_init(void)
{
	int argc;
	char *argv[1];

	/* Initialize GLUT global mutex */
	pthread_mutex_init(&x86_glut_mutex, NULL);

	/* List of events */
	x86_glut_event_list = linked_list_create();

	/* Host GLUT initialization */
	argc = 0;
	argv[0] = "m2s";
	glutInit(&argc, argv);
}


void x86_glut_done(void)
{
	struct x86_glut_event_t *event;

	/* Kill GLUT thread */
	if (x86_glut_thread)
		

	/* Free list of events */
	LINKED_LIST_FOR_EACH(x86_glut_event_list)
	{
		event = linked_list_get(x86_glut_event_list);
		x86_glut_event_free(event);
	}
	linked_list_free(x86_glut_event_list);
}


int x86_glut_call(void)
{
	int code;
	int ret;

	/* Function code */
	code = x86_isa_regs->ebx;
	if (code <= x86_glut_call_invalid || code >= x86_glut_call_count)
		fatal("%s: invalid GLUT function (code %d).\n%s",
			__FUNCTION__, code, err_x86_glut_code);

	/* Debug */
	x86_glut_debug("GLUT runtime call '%s' (code %d)\n",
		x86_glut_call_name[code], code);

	/* Call GLUT function */
	assert(x86_glut_func_table[code]);
	ret = x86_glut_func_table[code]();

	/* Return value */
	return ret;
}




/*
 * GLUT call #1 - init
 *
 * @param struct x86_glut_version_t *version;
 *	Structure where the version of the GLUT runtime implementation will be
 *	dumped. To succeed, the major version should match in the runtime
 *	library (guest) and runtime implementation (host), whereas the minor
 *	version should be equal or higher in the implementation (host).
 *
 *	Features should be added to the GLUT runtime (guest and host) using the
 *	following rules:
 *	1)  If the guest library requires a new feature from the host
 *	    implementation, the feature is added to the host, and the minor
 *	    version is updated to the current Multi2Sim SVN revision both in
 *	    host and guest.
 *          All previous services provided by the host should remain available
 *          and backward-compatible. Executing a newer library on the older
 *          simulator will fail, but an older library on the newer simulator
 *          will succeed.
 *      2)  If a new feature is added that affects older services of the host
 *          implementation breaking backward compatibility, the major version is
 *          increased by 1 in the host and guest code.
 *          Executing a library with a different (lower or higher) major version
 *          than the host implementation will fail.
 *
 * @return
 *	The runtime implementation version is return in argument 'version'.
 *	The return value is always 0.
 */

#define X86_GLUT_RUNTIME_VERSION_MAJOR	0
#define X86_GLUT_RUNTIME_VERSION_MINOR	680

struct x86_glut_version_t
{
	int major;
	int minor;
};

static int x86_glut_func_init(void)
{
	unsigned int version_ptr;

	struct x86_glut_version_t version;

	/* Arguments */
	version_ptr = x86_isa_regs->ecx;
	x86_glut_debug("\tversion_ptr=0x%x\n", version_ptr);

	/* Return version */
	assert(sizeof(struct x86_glut_version_t) == 8);
	version.major = X86_GLUT_RUNTIME_VERSION_MAJOR;
	version.minor = X86_GLUT_RUNTIME_VERSION_MINOR;
	mem_write(x86_isa_mem, version_ptr, sizeof version, &version);
	x86_glut_debug("\tGLUT Runtime host implementation v. %d.%d\n", version.major, version.minor);

	/* Return success */
	return 0;
}




/*
 * GLUT call #2 - get_event
 *
 * The function returns the next available GLUT event.
 *
 * @param struct x86_glut_event_t *event
 *	Pointer to a GLUT event structure where the next available event is
 *	written. If there is no new event, an event of type
 *	'x86_glut_event_idle' is returned.
 *
 * @return
 *	The return value is always 0.
 */

static int x86_glut_func_get_event(void)
{
	struct x86_glut_event_t *event;
	struct x86_glut_event_t idle_event;

	unsigned int event_ptr;

	/* Read arguments */
	event_ptr = x86_isa_regs->ecx;
	x86_glut_debug("\tevent_ptr=0x%x\n", event_ptr);

	/* Get event at the head of the queue. If there is no event, create an
	 * event of type 'idle'. */
	event = x86_glut_event_dequeue();
	if (event)
	{
		mem_write(x86_isa_mem, event_ptr, sizeof(struct x86_glut_event_t), event);
		x86_glut_event_free(event);
	}
	else
	{
		memset(&idle_event, 0, sizeof(struct x86_glut_event_t));
		idle_event.type = x86_glut_event_idle;
		mem_write(x86_isa_mem, event_ptr, sizeof(struct x86_glut_event_t), &idle_event);
	}

	/* Return event */
	return 0;
}



/*
 * GLUT call #3 - new_window
 *
 * @param char *title
 *	Title of the window.
 * @param struct x86_glut_window_properties_t *properties
 *	Pointer to a structure describing the window to be created.
 *
 * @return
 *	The host ID of the window, as returned by the GLUT host call.
 */

static int x86_glut_func_new_window(void)
{
	unsigned int title_ptr;
	unsigned int properties_ptr;

	char title[MAX_STRING_SIZE];

	int win;

	/* Read arguments */
	title_ptr = x86_isa_regs->ecx;
	properties_ptr = x86_isa_regs->edx;
	mem_read_string(x86_isa_mem, title_ptr, sizeof title, title);

	/* Debug */
	x86_glut_debug("\ttitle_ptr=0x%x, properties_ptr=0x%x\n",
		title_ptr, properties_ptr);
	x86_glut_debug("\ttitle='%s'\n", title);

	/* Create window */
	win = glutCreateWindow(title);
	glutDisplayFunc(x86_glut_display_func);
	glutOverlayDisplayFunc(x86_glut_overlay_display_func);
	glutReshapeFunc(x86_glut_reshape_func);
	glutKeyboardFunc(x86_glut_keyboard_func);
	glutMouseFunc(x86_glut_mouse_func);
	glutMotionFunc(x86_glut_motion_func);
	glutPassiveMotionFunc(x86_glut_passive_motion_func);
	glutVisibilityFunc(x86_glut_visibility_func);
	glutEntryFunc(x86_glut_entry_func);
	glutSpecialFunc(x86_glut_special_func);
	glutSpaceballRotateFunc(x86_glut_spaceball_rotate_func);
	glutSpaceballButtonFunc(x86_glut_spaceball_button_func);
	glutButtonBoxFunc(x86_glut_button_box_func);
	glutDialsFunc(x86_glut_dials_func);
	glutTabletMotionFunc(x86_glut_tablet_motion_func);
	glutTabletButtonFunc(x86_glut_tablet_button_func);

	/* Return window host ID */
	x86_glut_debug("\thost GLUT window ID = %d\n", win);
	return win;
}




/*
 * GLUT call #4 - main_loop
 *
 * Start GLUT host main loop, which will enqueues functions into the main event
 * list 'x86_glut_event_list' as they get received in the GLUT host windows.
 * Each call to GLUT call 'get_event' will return the event at the head of the
 * queue.
 *
 * @return
 *	The function always returns 0
 */

static void *x86_glut_thread_func(void *arg)
{
	glutMainLoop();
	return NULL;
}

static int x86_glut_func_main_loop(void)
{
	/* No previous thread must have been created */
	if (x86_glut_thread)
		fatal("%s: no concurrent GLUT loops allowed", __FUNCTION__);

	/* Spawn thread with GLUT main loop */
	if (pthread_create(&x86_glut_thread, NULL, x86_glut_thread_func, NULL))
		fatal("%s: could not create child thread", __FUNCTION__);

	/* Return */
	return 0;
}

