/*
 *  Multi2Sim
 *  Copyright (C) 2012  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <assert.h>

#include <arch/x86/emu/context.h>
#include <arch/x86/emu/regs.h>
#include <driver/glut/frame-buffer.h>
#include <lib/mhandle/mhandle.h>
#include <lib/util/debug.h>
#include <lib/util/list.h>
#include <mem-system/memory.h>

#include "buffers.h"
#include "context.h"
#include "light.h"
#include "material.h"
#include "matrix.h"
#include "matrix-stack.h"
#include "opengl.h"
#include "rasterizer.h"
#include "vertex.h"
#include "viewport.h"


static char *opengl_err_code =
	"\tAn invalid function code was generated by your application in a OpenGL system\n"
	"\tcall. Probably, this means that your application is using an incompatible\n"
	"\tversion of the Multi2Sim OpenGL runtime library ('libm2s-opengl'). Please\n"
	"\trecompile your application and try again.\n";

/* Debug */
int opengl_debug_category;


/* List of OPENGL runtime calls */
enum opengl_call_t
{
	opengl_call_invalid = 0,
#define OPENGL_DEFINE_CALL(name, code) opengl_call_##name = code,
#include "opengl.dat"
#undef OPENGL_DEFINE_CALL
	opengl_call_count
};


/* List of OPENGL runtime call names */
char *opengl_call_name[opengl_call_count + 1] =
{
	NULL,
#define OPENGL_DEFINE_CALL(name, code) #name,
#include "opengl.dat"
#undef OPENGL_DEFINE_CALL
	NULL
};


/* Forward declarations of OPENGL runtime functions */
#define OPENGL_DEFINE_CALL(name, code) \
	static int opengl_func_##name(struct x86_ctx_t *ctx);
#include "opengl.dat"
#undef OPENGL_DEFINE_CALL


/* List of OPENGL runtime functions */
typedef int (*opengl_func_t)(struct x86_ctx_t *ctx);
static opengl_func_t opengl_func_table[opengl_call_count + 1] =
{
	NULL,
#define OPENGL_DEFINE_CALL(name, code) opengl_func_##name,
#include "opengl.dat"
#undef OPENGL_DEFINE_CALL
	NULL
};


/*
 * OpenGL global variables
 */

/* OpenGL Context */
struct opengl_context_t *opengl_ctx;

void opengl_init(void)
{
	opengl_debug("Initializing OpenGL context\n");
	opengl_ctx = opengl_context_create();
}


void opengl_done(void)
{
	if (opengl_ctx != NULL)
		opengl_context_free(opengl_ctx);
}


int opengl_abi_call(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;

	/* Variables */
	int code;
	int ret;

	/* Function code */
	code = regs->ebx;
	if (code <= opengl_call_invalid || code >= opengl_call_count)
		fatal("%s: invalid OpenGL function (code %d).\n%s",
			__FUNCTION__, code, opengl_err_code);

	/* Debug */
	opengl_debug("OpenGL runtime call '%s' (code %d)\n",
		opengl_call_name[code], code);

	/* Call OPENGL function */
	assert(opengl_func_table[code]);
	ret = opengl_func_table[code](ctx);

	/* Return value */
	return ret;
}

/*
 * OpenGL call #1 - glDrawBuffer
 *
 * glDrawBuffer - specify which color buffers are to be drawn into
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glDrawBuffer(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	/* Variables */
	unsigned int mode_ptr;

	/* Read arguments */
	mode_ptr = regs->ecx;
	opengl_debug("\tmode_ptr=0x%x\n", mode_ptr);

	GLenum mode;

	mem_read(mem, mode_ptr, sizeof(GLenum), &mode);

	/* Set color buffers */
	fatal("Not implemented yet!\n");

	/* Return success */
	return 0;
}


/*
 * OpenGL call #2 - glReadBuffer
 *
 * glReadBuffer - select a color buffer source for pixels
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glReadBuffer(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int mode_ptr;

	/* Read arguments */
	mode_ptr = regs->ecx;
	opengl_debug("\tmode_ptr=0x%x\n", mode_ptr);

	GLenum mode;
	mem_read(mem, mode_ptr, sizeof(GLenum), &mode);

	/* Set color buffers */
	fatal("Not implemented yet!\n");

	/* Return success */
	return 0;
}
/*
 * OpenGL call #3 - glEnable
 *
 * glEnable - enable server-side GL capabilities
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glEnable(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int cap_ptr;

	/* Read arguments */
	cap_ptr = regs->ecx;
	opengl_debug("\tcap_ptr=0x%x\n", cap_ptr);

	GLenum cap;

	mem_read(mem, cap_ptr, sizeof(GLenum), &cap);

	switch(cap)
	{

	case GL_ALPHA_TEST:

		{
			opengl_ctx->context_cap->is_alpha_test = GL_TRUE;
			opengl_debug("\tGL_ALPHA_TEST enabled!\n");
			break;
		}

	case GL_AUTO_NORMAL:

		{
			opengl_ctx->context_cap->is_auto_normal = GL_TRUE;
			opengl_debug("\tGL_AUTO_NORMAL enabled!\n");
			break;
		}

	case GL_BLEND:

		{
			opengl_ctx->context_cap->is_blend = GL_TRUE;
			opengl_debug("\tGL_BLEND enabled!\n");
			break;
		}

	case GL_CLIP_PLANE0:

		{
			opengl_ctx->context_cap->is_clip_plane0 = GL_TRUE;
			opengl_debug("\tGL_CLIP_PLANE0 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE1:

		{
			opengl_ctx->context_cap->is_clip_plane1 = GL_TRUE;
			opengl_debug("\tGL_CLIP_PLANE1 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE2:

		{
			opengl_ctx->context_cap->is_clip_plane2 = GL_TRUE;
			opengl_debug("\tGL_CLIP_PLANE2 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE3:

		{
			opengl_ctx->context_cap->is_clip_plane3 = GL_TRUE;
			opengl_debug("\tGL_CLIP_PLANE3 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE4:

		{
			opengl_ctx->context_cap->is_clip_plane4 = GL_TRUE;
			opengl_debug("\tGL_CLIP_PLANE4 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE5:

		{
			opengl_ctx->context_cap->is_clip_plane5 = GL_TRUE;
			opengl_debug("\tGL_CLIP_PLANE5 enabled!\n");
			break;
		}

	case GL_COLOR_LOGIC_OP:

		{
			opengl_ctx->context_cap->is_color_logic_op = GL_TRUE;
			opengl_debug("\tGL_COLOR_LOGIC_OP enabled!\n");
			break;
		}

	case GL_COLOR_MATERIAL:

		{
			opengl_ctx->context_cap->is_color_material = GL_TRUE;
			opengl_debug("\tGL_COLOR_MATERIAL enabled!\n");
			break;
		}

	case GL_COLOR_SUM:

		{
			opengl_ctx->context_cap->is_color_sum = GL_TRUE;
			opengl_debug("\tGL_COLOR_SUM enabled!\n");
			break;
		}

	case GL_COLOR_TABLE:

		{
			opengl_ctx->context_cap->is_color_table = GL_TRUE;
			opengl_debug("\tGL_COLOR_TABLE enabled!\n");
			break;
		}

	case GL_CONVOLUTION_1D:

		{
			opengl_ctx->context_cap->is_convolution_1d = GL_TRUE;
			opengl_debug("\tGL_CONVOLUTION_1D enabled!\n");
			break;
		}

	case GL_CONVOLUTION_2D:

		{
			opengl_ctx->context_cap->is_convolution_2d = GL_TRUE;
			opengl_debug("\tGL_CONVOLUTION_2D enabled!\n");
			break;
		}

	case GL_CULL_FACE:

		{
			opengl_ctx->context_cap->is_cull_face = GL_TRUE;
			opengl_debug("\tGL_CULL_FACE enabled!\n");
			break;
		}

	case GL_DEPTH_TEST:

		{
			opengl_ctx->context_cap->is_depth_test = GL_TRUE;
			opengl_debug("\tGL_DEPTH_TEST enabled!\n");
			break;
		}

	case GL_DITHER:

		{
			opengl_ctx->context_cap->is_dither = GL_TRUE;
			opengl_debug("\tGL_DITHER enabled!\n");
			break;
		}

	case GL_FOG:

		{
			opengl_ctx->context_cap->is_fog = GL_TRUE;
			opengl_debug("\tGL_FOG enabled!\n");
			break;
		}

	case GL_HISTOGRAM:

		{
			opengl_ctx->context_cap->is_histogram = GL_TRUE;
			opengl_debug("\tGL_HISTOGRAM enabled!\n");
			break;
		}

	case GL_INDEX_LOGIC_OP:

		{
			opengl_ctx->context_cap->is_index_logic_op = GL_TRUE;
			opengl_debug("\tGL_INDEX_LOGIC_OP enabled!\n");
			break;
		}

	case GL_LIGHT0:

		{
			opengl_ctx->light->Light[0]->Enabled = GL_TRUE;
			opengl_debug("\tGL_LIGHT0 enabled!\n");
			break;
		}

	case GL_LIGHT1:

		{
			opengl_ctx->light->Light[1]->Enabled = GL_TRUE;
			opengl_debug("\tGL_LIGHT1 enabled!\n");
			break;
		}

	case GL_LIGHT2:

		{
			opengl_ctx->light->Light[2]->Enabled = GL_TRUE;
			opengl_debug("\tGL_LIGHT2 enabled!\n");
			break;
		}

	case GL_LIGHT3:

		{
			opengl_ctx->light->Light[3]->Enabled = GL_TRUE;
			opengl_debug("\tGL_LIGHT3 enabled!\n");
			break;
		}

	case GL_LIGHT4:

		{
			opengl_ctx->light->Light[4]->Enabled = GL_TRUE;
			opengl_debug("\tGL_LIGHT4 enabled!\n");
			break;
		}

	case GL_LIGHT5:

		{
			opengl_ctx->light->Light[5]->Enabled = GL_TRUE;
			opengl_debug("\tGL_LIGHT5 enabled!\n");
			break;
		}

	case GL_LIGHT6:

		{
			opengl_ctx->light->Light[6]->Enabled = GL_TRUE;
			opengl_debug("\tGL_LIGHT6 enabled!\n");
			break;
		}

	case GL_LIGHT7:

		{
			opengl_ctx->light->Light[7]->Enabled = GL_TRUE;
			opengl_debug("\tGL_LIGHT7 enabled!\n");
			break;
		}

	case GL_LIGHTING:

		{
			opengl_ctx->light->Enabled = GL_TRUE;
			opengl_debug("\tGL_LIGHTING enabled!\n");
			break;
		}

	case GL_LINE_SMOOTH:

		{
			opengl_ctx->context_cap->is_line_smooth = GL_TRUE;
			opengl_debug("\tGL_LINE_SMOOTH enabled!\n");
			break;
		}

	case GL_LINE_STIPPLE:

		{
			opengl_ctx->context_cap->is_line_stipple = GL_TRUE;
			opengl_debug("\tGL_LINE_STIPPLE enabled!\n");
			break;
		}

	case GL_MAP1_COLOR_4:

		{
			opengl_ctx->context_cap->is_map1_color_4 = GL_TRUE;
			opengl_debug("\tGL_MAP1_COLOR_4 enabled!\n");
			break;
		}

	case GL_MAP1_INDEX:

		{
			opengl_ctx->context_cap->is_map1_index = GL_TRUE;
			opengl_debug("\tGL_MAP1_INDEX enabled!\n");
			break;
		}

	case GL_MAP1_NORMAL:

		{
			opengl_ctx->context_cap->is_map1_normal = GL_TRUE;
			opengl_debug("\tGL_MAP1_NORMAL enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_1:

		{
			opengl_ctx->context_cap->is_map1_texture_coord_1 = GL_TRUE;
			opengl_debug("\tGL_MAP1_TEXTURE_COORD_1 enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_2:

		{
			opengl_ctx->context_cap->is_map1_texture_coord_2 = GL_TRUE;
			opengl_debug("\tGL_MAP1_TEXTURE_COORD_2 enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_3:

		{
			opengl_ctx->context_cap->is_map1_texture_coord_3 = GL_TRUE;
			opengl_debug("\tGL_MAP1_TEXTURE_COORD_3 enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_4:

		{
			opengl_ctx->context_cap->is_map1_texture_coord_4 = GL_TRUE;
			opengl_debug("\tGL_MAP1_TEXTURE_COORD_4 enabled!\n");
			break;
		}

	case GL_MAP1_VERTEX_3:

		{
			opengl_ctx->context_cap->is_map1_vertex_3 = GL_TRUE;
			opengl_debug("\tGL_MAP1_VERTEX_3 enabled!\n");
			break;
		}

	case GL_MAP1_VERTEX_4:

		{
			opengl_ctx->context_cap->is_map1_vertex_4 = GL_TRUE;
			opengl_debug("\tGL_MAP1_VERTEX_4 enabled!\n");
			break;
		}

	case GL_MAP2_COLOR_4:

		{
			opengl_ctx->context_cap->is_map2_color_4 = GL_TRUE;
			opengl_debug("\tGL_MAP2_COLOR_4 enabled!\n");
			break;
		}

	case GL_MAP2_INDEX:

		{
			opengl_ctx->context_cap->is_map2_index = GL_TRUE;
			opengl_debug("\tGL_MAP2_INDEX enabled!\n");
			break;
		}

	case GL_MAP2_NORMAL:

		{
			opengl_ctx->context_cap->is_map2_normal = GL_TRUE;
			opengl_debug("\tGL_MAP2_NORMAL enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_1:

		{
			opengl_ctx->context_cap->is_map2_texture_coord_1 = GL_TRUE;
			opengl_debug("\tGL_MAP2_TEXTURE_COORD_1 enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_2:

		{
			opengl_ctx->context_cap->is_map2_texture_coord_2 = GL_TRUE;
			opengl_debug("\tGL_MAP2_TEXTURE_COORD_2 enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_3:

		{
			opengl_ctx->context_cap->is_map2_texture_coord_3 = GL_TRUE;
			opengl_debug("\tGL_MAP2_TEXTURE_COORD_3 enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_4:

		{
			opengl_ctx->context_cap->is_map2_texture_coord_4 = GL_TRUE;
			opengl_debug("\tGL_MAP2_TEXTURE_COORD_4 enabled!\n");
			break;
		}

	case GL_MAP2_VERTEX_3:

		{
			opengl_ctx->context_cap->is_map2_vertex_3 = GL_TRUE;
			opengl_debug("\tGL_MAP2_VERTEX_3 enabled!\n");
			break;
		}

	case GL_MAP2_VERTEX_4:

		{
			opengl_ctx->context_cap->is_map2_vertex_4 = GL_TRUE;
			opengl_debug("\tGL_MAP2_VERTEX_4 enabled!\n");
			break;
		}

	case GL_MINMAX:

		{
			opengl_ctx->context_cap->is_minmax = GL_TRUE;
			opengl_debug("\tGL_MINMAX enabled!\n");
			break;
		}

	case GL_MULTISAMPLE:

		{
			opengl_ctx->context_cap->is_multisample = GL_TRUE;
			opengl_debug("\tGL_MULTISAMPLE enabled!\n");
			break;
		}

	case GL_NORMALIZE:

		{
			opengl_ctx->context_cap->is_normalize = GL_TRUE;
			opengl_debug("\tGL_NORMALIZE enabled!\n");
			break;
		}

	case GL_POINT_SMOOTH:

		{
			opengl_ctx->context_cap->is_point_smooth = GL_TRUE;
			opengl_debug("\tGL_POINT_SMOOTH enabled!\n");
			break;
		}

	case GL_POINT_SPRITE:

		{
			opengl_ctx->context_cap->is_point_sprite = GL_TRUE;
			opengl_debug("\tGL_POINT_SPRITE enabled!\n");
			break;
		}

	case GL_POLYGON_OFFSET_FILL:

		{
			opengl_ctx->context_cap->is_polygon_offset_fill = GL_TRUE;
			opengl_debug("\tGL_POLYGON_OFFSET_FILL enabled!\n");
			break;
		}

	case GL_POLYGON_OFFSET_LINE:

		{
			opengl_ctx->context_cap->is_polygon_offset_line = GL_TRUE;
			opengl_debug("\tGL_POLYGON_OFFSET_LINE enabled!\n");
			break;
		}

	case GL_POLYGON_OFFSET_POINT:

		{
			opengl_ctx->context_cap->is_polygon_offset_point = GL_TRUE;
			opengl_debug("\tGL_POLYGON_OFFSET_POINT enabled!\n");
			break;
		}

	case GL_POLYGON_SMOOTH:

		{
			opengl_ctx->context_cap->is_polygon_smooth = GL_TRUE;
			opengl_debug("\tGL_POLYGON_SMOOTH enabled!\n");
			break;
		}

	case GL_POLYGON_STIPPLE:

		{
			opengl_ctx->context_cap->is_polygon_stipple = GL_TRUE;
			opengl_debug("\tGL_POLYGON_STIPPLE enabled!\n");
			break;
		}

	case GL_POST_COLOR_MATRIX_COLOR_TABLE:

		{
			opengl_ctx->context_cap->is_post_color_matrix_color_table = GL_TRUE;
			opengl_debug("\tGL_POST_COLOR_MATRIX_COLOR_TABLE enabled!\n");
			break;
		}

	case GL_POST_CONVOLUTION_COLOR_TABLE:

		{
			opengl_ctx->context_cap->is_post_convolution_color_table = GL_TRUE;
			opengl_debug("\tGL_POST_CONVOLUTION_COLOR_TABLE enabled!\n");
			break;
		}

	case GL_RESCALE_NORMAL:

		{
			opengl_ctx->context_cap->is_rescale_normal = GL_TRUE;
			opengl_debug("\tGL_RESCALE_NORMAL enabled!\n");
			break;
		}

	case GL_SAMPLE_ALPHA_TO_COVERAGE:

		{
			opengl_ctx->context_cap->is_sample_alpha_to_coverage = GL_TRUE;
			opengl_debug("\tGL_SAMPLE_ALPHA_TO_COVERAGE enabled!\n");
			break;
		}

	case GL_SAMPLE_ALPHA_TO_ONE:

		{
			opengl_ctx->context_cap->is_sample_alpha_to_one = GL_TRUE;
			opengl_debug("\tGL_SAMPLE_ALPHA_TO_ONE enabled!\n");
			break;
		}

	case GL_SAMPLE_COVERAGE:

		{
			opengl_ctx->context_cap->is_sample_coverage = GL_TRUE;
			opengl_debug("\tGL_SAMPLE_COVERAGE enabled!\n");
			break;
		}

	case GL_SEPARABLE_2D:

		{
			opengl_ctx->context_cap->is_separable_2d = GL_TRUE;
			opengl_debug("\tGL_SEPARABLE_2D enabled!\n");
			break;
		}

	case GL_SCISSOR_TEST:

		{
			opengl_ctx->context_cap->is_scissor_test = GL_TRUE;
			opengl_debug("\tGL_SCISSOR_TEST enabled!\n");
			break;
		}

	case GL_STENCIL_TEST:

		{
			opengl_ctx->context_cap->is_stencil_test = GL_TRUE;
			opengl_debug("\tGL_STENCIL_TEST enabled!\n");
			break;
		}

	case GL_TEXTURE_1D:

		{
			opengl_ctx->context_cap->is_texture_1d = GL_TRUE;
			opengl_debug("\tGL_TEXTURE_1D enabled!\n");
			break;
		}

	case GL_TEXTURE_2D:

		{
			opengl_ctx->context_cap->is_texture_2d = GL_TRUE;
			opengl_debug("\tGL_TEXTURE_2D enabled!\n");
			break;
		}

	case GL_TEXTURE_3D:

		{
			opengl_ctx->context_cap->is_texture_3d = GL_TRUE;
			opengl_debug("\tGL_TEXTURE_3D enabled!\n");
			break;
		}

	case GL_TEXTURE_CUBE_MAP:

		{
			opengl_ctx->context_cap->is_texture_cube_map = GL_TRUE;
			opengl_debug("\tGL_TEXTURE_CUBE_MAP enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_Q:

		{
			opengl_ctx->context_cap->is_texture_gen_q = GL_TRUE;
			opengl_debug("\tGL_TEXTURE_GEN_Q enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_R:

		{
			opengl_ctx->context_cap->is_texture_gen_r = GL_TRUE;
			opengl_debug("\tGL_TEXTURE_GEN_R enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_S:

		{
			opengl_ctx->context_cap->is_texture_gen_s = GL_TRUE;
			opengl_debug("\tGL_TEXTURE_GEN_S enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_T:

		{
			opengl_ctx->context_cap->is_texture_gen_t = GL_TRUE;
			opengl_debug("\tGL_TEXTURE_GEN_T enabled!\n");
			break;
		}

	case GL_VERTEX_PROGRAM_POINT_SIZE:

		{
			opengl_ctx->context_cap->is_vertex_program_point_size = GL_TRUE;
			opengl_debug("\tGL_VERTEX_PROGRAM_POINT_SIZE enabled!\n");
			break;
		}

	case GL_VERTEX_PROGRAM_TWO_SIDE:

		{
			opengl_ctx->context_cap->is_vertex_program_two_side = GL_TRUE;
			opengl_debug("\tGL_VERTEX_PROGRAM_TWO_SIDE enabled!\n");
			break;
		}

	default:
		break;
	}

	/* Return success */
	return 0;
}

/*
 * OpenGL call #4 - glViewport
 *
 * glViewport - set the viewport
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glViewport(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int args_ptr;

	/* Read arguments */
	args_ptr = regs->ecx;

	opengl_debug("\targs_ptr=0x%x\n", args_ptr);

	/* Get function info */
	int func_args[4];

	/* GLint == GLsizei == int */
	mem_read(mem, args_ptr, 4*sizeof(GLint), func_args);
	opengl_ctx->viewport->x = func_args[0];
	opengl_ctx->viewport->y = func_args[1];
	opengl_ctx->viewport->width = func_args[2];
	opengl_ctx->viewport->height = func_args[3];

	/* Initialize */
	opengl_debug("\tviewport: x=%d, y=%d, width=%d, height=%d\n",
				opengl_ctx->viewport->x, opengl_ctx->viewport->y, 
				opengl_ctx->viewport->width, opengl_ctx->viewport->height);

	/* Update frame buffer */
	/* FIXME: Viewport size != frame buffer size, it only selects a part of frame buffer */
	opengl_frame_buffer_resize(opengl_ctx->draw_buffer, 
		opengl_ctx->viewport->width, opengl_ctx->viewport->height);
	opengl_frame_buffer_resize(opengl_ctx->read_buffer, 
		opengl_ctx->viewport->width, opengl_ctx->viewport->height);
	
	glut_frame_buffer_resize(opengl_ctx->viewport->width, opengl_ctx->viewport->height);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #5 - glMatrixMode
 *
 * glMatrixMode - specify which matrix is the current matrix
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glMatrixMode(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int mtx_mode_ptr;
	GLenum mtx_mod;

	/* Read arguments */
	mtx_mode_ptr = regs->ecx;
	opengl_debug("\tmtx_mode_ptr=0x%x\n", mtx_mode_ptr);

	mem_read(mem, mtx_mode_ptr, sizeof(GLenum), &mtx_mod);

	/* Set up current matrix */
	switch(mtx_mod)
	{
		case	GL_MODELVIEW:
		{
			opengl_ctx->current_matrix_stack = opengl_ctx->modelview_matrix_stack;
			opengl_debug("\t\tCurrent Matrix Stack = Modelview Matrix Stack\n");
			break;
		}
			
		case	GL_PROJECTION:
		{
			opengl_ctx->current_matrix_stack = opengl_ctx->projection_matrix_stack;
			opengl_debug("\t\tCurrent Matrix Stack = Projection Matrix Stack \n");
			break;
		}

		case	GL_TEXTURE:
		{
			/* FIXME: choose which one? */
			opengl_ctx->current_matrix_stack = opengl_ctx->texture_matrix_stack[0];
			opengl_debug("\t\tCurrent Matrix Stack = Texture Matrix Stack\n");
			break;
		}

		case	GL_COLOR:
		{
			opengl_ctx->current_matrix_stack = opengl_ctx->color_matrix_stack;
			opengl_debug("\t\tCurrent Matrix Stack = Color Matrix Stack\n");
			break;
		}
		default:
			break;
	}

	/* Return */
	return 0;	
}

/*
 * OpenGL call #6 - glLoadIdentity
 *
 * glLoadIdentity - replace the current matrix with the identity matrix
 *		       the current matrix in any mode is the matrix on the top of the stack for that mode.
 * @return
 *	The function always returns 0
 */

static int opengl_func_glLoadIdentity(struct x86_ctx_t *ctx)
{
	struct opengl_matrix_t *mtx_idt;
	struct opengl_matrix_t *mtx_curr;

	int i;
	int j;

	/* Replace current matrix stack */
	mtx_idt = opengl_matrix_create(MATRIX_IDENTITY);
	mtx_curr = opengl_context_get_current_matrix(opengl_ctx);

	opengl_matrix_copy(mtx_curr, mtx_idt);

	opengl_debug("\t\tCurr:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_curr->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	/* Free */
	opengl_matrix_free(mtx_idt);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #7 - glOrtho
 *
 * glOrtho - multiply the current matrix with an orthographic matrix
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glOrtho(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int args_ptr;

	int i;
	int j;

	/* Read arguments */
	args_ptr = regs->ecx;

	opengl_debug("\targs_ptr=0x%x\n", args_ptr);

	/* Get function info */
	GLdouble func_args[6];
	mem_read(mem, args_ptr, 6 * sizeof(GLdouble), func_args);
	for (i = 0; i < 6; i++)
		opengl_debug("\t\targs[%d] = %f (0x%f)\n",
			i, func_args[i], func_args[i]);

	/* Current matrix multiplies orthographic matrix */
	struct opengl_matrix_t *mtx_ortho;
	struct opengl_matrix_t *mtx_curr;

	GLfloat left = func_args[0];
	GLfloat right = func_args[1];
	GLfloat bottom = func_args[2];
	GLfloat top = func_args[3];
	GLfloat nearval = func_args[4];
	GLfloat farval = func_args[5];

	/* Initialize orthographic matrix */
	mtx_ortho = opengl_ortho_matrix_create(left, right, bottom, top, nearval, farval);

	opengl_debug("\t\tOrtho:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_ortho->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	mtx_curr = opengl_context_get_current_matrix(opengl_ctx);
	opengl_debug("\t\tCurr:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_curr->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	opengl_matrix_mul_matrix(mtx_curr, mtx_curr, mtx_ortho);
	opengl_debug("\t\tCurr mul Ortho:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_curr->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	/* Free */
	opengl_ortho_matrix_free(mtx_ortho);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #8 - glClear
 *
 * glClear - clear buffers to present values
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glClear(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int mask_ptr;
	GLbitfield mask;

	/* Read arguments */
	mask_ptr = regs->ecx;
	mem_read(mem, mask_ptr, sizeof(GLbitfield), &mask);
	opengl_debug("\tmask_ptr=0x%x\n", mask_ptr);
	opengl_debug("\tmask=0x%x\n", mask);

	/* Clear frame buffers*/
	opengl_frame_buffer_clear(opengl_ctx->draw_buffer, mask);
	opengl_frame_buffer_clear(opengl_ctx->read_buffer, mask);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #9 - glBegin
 *
 * glBegin - delimit the vertices of a primitive or a group of like primitives
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glBegin(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int mode_ptr;
	GLenum mode;

	/* Read arguments */
	mode_ptr = regs->ecx;
	mem_read(mem, mode_ptr, sizeof(GLenum), &mode);
	opengl_debug("\tmode_ptr=0x%x\n", mode_ptr);
	opengl_debug("\tmode=0x%x\n", mode);

	/* Preparation a primitive group for glVertex to insert vertex */
	struct opengl_vertex_group_t *vtxgp;
	vtxgp = opengl_vertex_group_create(mode);
	opengl_vertex_buffer_add_vertex_group(opengl_ctx->vertex_buffer, vtxgp);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #10 - glEnd
 *
 * glEnd - delimit the vertices of a primitive or a group of like primitives
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glEnd(struct x86_ctx_t *ctx)
{
	/* Set current vertex group to NULL */
	opengl_ctx->vertex_buffer->current_vertex_group = NULL;

	/* Return */
	return 0;	
}

/*
 * OpenGL call #11 - glVertex2f
 *
 * glVertex2f - specify a vertex
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glVertex2f(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	struct opengl_matrix_t *mtx_mdlvw = NULL;
	struct opengl_matrix_t *mtx_prjct = NULL;

	unsigned int args_ptr;
	int i;

	/* Read arguments */
	args_ptr = regs->ecx;

	opengl_debug("\targs_ptr=0x%x\n", args_ptr);

	/* Get function info */
	GLfloat func_args[2];
	mem_read(mem, args_ptr, 2 * sizeof(GLfloat), func_args);
	for (i = 0; i < 2; i++)
		opengl_debug("\t\targs[%d] = %f\n",
			i, func_args[i]);

	/* Add a vertex */
	struct opengl_vertex_t *vertex;

	/* Set position */
	/* x=x. y=y, z=0.0f, w= 1.0f */	
	vertex = opengl_vertex_create(func_args[0], func_args[1], (GLfloat)0.0f, (GLfloat)1.0f);
	/* Set normal */
	opengl_vertex_set_normal(opengl_ctx->current_normal, vertex);

	mtx_mdlvw = opengl_matrix_stack_top(opengl_ctx->modelview_matrix_stack);
	mtx_prjct = opengl_matrix_stack_top(opengl_ctx->projection_matrix_stack);

	/* Multiply ModelView Matrix */
	opengl_matrix_mul_vertex(vertex, mtx_mdlvw);
	/* Multiply Projection Matrix */
	opengl_matrix_mul_vertex(vertex, mtx_prjct);

	/* Lighting or Coloring */
	if (opengl_ctx->light->Enabled)
		opengl_light_apply_all(vertex, opengl_ctx->light);
	else
		opengl_vertex_set_color(opengl_ctx->current_color, vertex);
	
	/* Add vertex */
	opengl_vertex_buffer_add_vertex(opengl_ctx->vertex_buffer, vertex);


	/* Return */
	return 0;	
}

/*
 * OpenGL call #12 - glVertex3f
 *
 * glVertex3f - specify a vertex
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glVertex3f(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	struct opengl_matrix_t *mtx_mdlvw = NULL;
	struct opengl_matrix_t *mtx_prjct = NULL;

	unsigned int args_ptr;
	int i;

	/* Read arguments */
	args_ptr = regs->ecx;
	opengl_debug("\targs_ptr=0x%x\n", args_ptr);

	/* Get function info */
	GLfloat func_args[3];
	mem_read(mem, args_ptr, 3 * sizeof(GLfloat), func_args);
	for (i = 0; i < 3; i++)
		opengl_debug("\t\targs[%d] = %f\n",
			i, func_args[i]);

	/* Add a vertex to vertex buffer */
	struct opengl_vertex_t *vertex;

	/* Set position */
	/* x=x, y=y, z=z, w= 1.0f */
	vertex = opengl_vertex_create(func_args[0], func_args[1], func_args[2], (GLfloat)1.0f);
	/* Set normal */
	opengl_vertex_set_normal(opengl_ctx->current_normal, vertex);

	mtx_mdlvw = opengl_matrix_stack_top(opengl_ctx->modelview_matrix_stack);
	mtx_prjct = opengl_matrix_stack_top(opengl_ctx->projection_matrix_stack);

	/* Multiply ModelView Matrix */
	opengl_matrix_mul_vertex(vertex, mtx_mdlvw);
	/* Multiply Projection Matrix */
	opengl_matrix_mul_vertex(vertex, mtx_prjct);

	/* Lighting or Coloring */
	if (opengl_ctx->light->Enabled)
		opengl_light_apply_all(vertex, opengl_ctx->light);
	else
		opengl_vertex_set_color(opengl_ctx->current_color, vertex);

	opengl_vertex_buffer_add_vertex(opengl_ctx->vertex_buffer, vertex);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #13 - glFlush
 *
 * glFlush -  force execution of GL commands in finite time
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glFlush(struct x86_ctx_t *ctx)
{
	int i;
	int j;
	// int k;
	int width;
	int height;
	int vtx_color;
	struct opengl_vertex_group_t *vtxgp = NULL;
	struct opengl_vertex_t *vtx = NULL;
	struct opengl_vertex_t *vtx0 = NULL;
	struct opengl_vertex_t *vtx1 = NULL;
	struct opengl_vertex_t *vtx2 = NULL;	
	struct opengl_vertex_t *vtx3 = NULL;	
	// struct opengl_matrix_t *mtx_mdlvw = NULL;
	// struct opengl_matrix_t *mtx_prjct = NULL;

	int vtxgp_count = list_count(opengl_ctx->vertex_buffer->vertex_groups); 

	/* Clear frame buffer */
	glut_frame_buffer_clear();

	/* Draw pattern */
	glut_frame_buffer_get_size(&width, &height);
	opengl_debug("\t\tViewport \t[%d, %d, %d, %d]\n",
			opengl_ctx->viewport->x, opengl_ctx->viewport->y,
			opengl_ctx->viewport->width, opengl_ctx->viewport->height);
	// mtx_mdlvw = opengl_matrix_stack_top(opengl_ctx->modelview_matrix_stack);
	// mtx_prjct = opengl_matrix_stack_top(opengl_ctx->projection_matrix_stack);

	for (i = 0; i < vtxgp_count; ++i)
	{
		vtxgp = list_get(opengl_ctx->vertex_buffer->vertex_groups, i);
		int vtx_count = list_count(vtxgp->vertex_list);
		for (j = 0; j < vtx_count; ++j)
		{
			vtx = list_get(vtxgp->vertex_list, j);
			/* Multiply ModelView Matrix */
			// opengl_matrix_mul_vertex(vtx, mtx_mdlvw);
			/* Multiply Projection Matrix */
			// opengl_matrix_mul_vertex(vtx, mtx_prjct);
			/* Clipping */
			/* Lighting*/
			// if (opengl_ctx->light->Enabled)
			// {
			// 	for (k = 0; k < MAX_LIGHTS; ++k)
			// 	{		
			// 		opengl_light_apply_all(vtx, opengl_ctx->light);
			// 	}
			// }
			/* Perspective division */
			vtx->pos[X_COMP] /= vtx->pos[W_COMP];
			vtx->pos[Y_COMP] /= vtx->pos[W_COMP];
			vtx->pos[Z_COMP] /= vtx->pos[W_COMP];
			opengl_debug("\t\tUpdated Vertex \t[%f, %f, %f, %f]\n", vtx->pos[X_COMP], vtx->pos[Y_COMP], vtx->pos[Z_COMP], vtx->pos[W_COMP]);
			/* To screen coordinate */			
			vtx->pos[X_COMP] = (vtx->pos[X_COMP] + 1) * opengl_ctx->viewport->width*0.5+ opengl_ctx->viewport->x;
			vtx->pos[Y_COMP] = (vtx->pos[Y_COMP] + 1) * opengl_ctx->viewport->height*0.5+ opengl_ctx->viewport->y;	
			vtx->pos[Z_COMP] *= abs(opengl_ctx->viewport->far - opengl_ctx->viewport->near) / 2 
				+ (opengl_ctx->viewport->near + opengl_ctx->viewport->far);
			opengl_debug("\t\tScreen position\t[%f, %f, %f, %f]\n", vtx->pos[X_COMP], vtx->pos[Y_COMP], vtx->pos[Z_COMP], vtx->pos[W_COMP]);
			glut_frame_buffer_pixel(vtx->pos[X_COMP], vtx->pos[Y_COMP], 255);
		}
		/* Draw */
		switch(vtxgp->primitive_type)
		{
			case GL_POINTS:
			{
				for (j = 0; j < vtx_count; ++j)
				{
					vtx = list_get(vtxgp->vertex_list, j);
					opengl_debug("\t\tPoint position\t[%f, %f]\n", vtx->pos[X_COMP], vtx->pos[Y_COMP]);
					vtx_color = opengl_vertex_get_color(vtx);
					glut_frame_buffer_pixel(vtx->pos[X_COMP], vtx->pos[Y_COMP], vtx_color);
					break;
				}
			}
			case GL_LINES:
			{
				for (j = 0; j < vtx_count / 2; ++j)
				{
					vtx0 = list_get(vtxgp->vertex_list, 2*j);			
					vtx1 = list_get(vtxgp->vertex_list, 2*j+1);
					opengl_debug("\t\tLine starts \t[%f, %f]\n", vtx0->pos[X_COMP], vtx0->pos[Y_COMP]);
					opengl_debug("\t\tLine ends \t[%f, %f]\n", vtx1->pos[X_COMP], vtx1->pos[Y_COMP]);
					vtx_color = opengl_vertex_get_color(vtx0);					
					opengl_rasterizer_draw_line(opengl_ctx,  vtx0->pos[X_COMP],  vtx0->pos[Y_COMP], vtx1->pos[X_COMP], vtx1->pos[Y_COMP], vtx_color);
				}
				break;
			}
			case GL_LINE_LOOP:
			{
				for (j = 0; j < vtx_count; ++j)
				{
					vtx0 = list_get(vtxgp->vertex_list, j);			
					vtx1 = list_get(vtxgp->vertex_list, (j+1) % vtx_count);
					opengl_debug("\t\tLine starts \t[%f, %f]\n", vtx0->pos[X_COMP], vtx0->pos[Y_COMP]);
					opengl_debug("\t\tLine ends \t[%f, %f]\n", vtx1->pos[X_COMP], vtx1->pos[Y_COMP]);
					vtx_color = opengl_vertex_get_color(vtx0);
					opengl_rasterizer_draw_line(opengl_ctx, vtx0->pos[X_COMP], vtx0->pos[Y_COMP], vtx1->pos[X_COMP], vtx1->pos[Y_COMP], vtx_color);
				}				
				break;
			}
			case GL_LINE_STRIP:
			{
				for (j = 0; j < vtx_count - 1; ++j)
				{
					vtx0 = list_get(vtxgp->vertex_list, j);			
					vtx1 = list_get(vtxgp->vertex_list, j+1);
					opengl_debug("\t\tLine starts \t[%f, %f]\n", vtx0->pos[X_COMP], vtx0->pos[Y_COMP]);
					opengl_debug("\t\tLine ends \t[%f, %f]\n", vtx1->pos[X_COMP], vtx1->pos[Y_COMP]);
					vtx_color = opengl_vertex_get_color(vtx0);
					opengl_rasterizer_draw_line(opengl_ctx, vtx0->pos[X_COMP], vtx0->pos[Y_COMP], vtx1->pos[X_COMP], vtx1->pos[Y_COMP], vtx_color);
				}
				break;
			}
			case GL_TRIANGLES:
			{
				vtx0 = list_get(vtxgp->vertex_list, 0);
				vtx1 = list_get(vtxgp->vertex_list, 1);
				vtx2 = list_get(vtxgp->vertex_list, 2);
				opengl_rasterizer_draw_triangle(opengl_ctx, vtx0, vtx1, vtx2);
				break;
			}
			case GL_TRIANGLE_STRIP:
			{
				break;
			}
			case GL_TRIANGLE_FAN:
			{
				break;
			}
			case GL_QUADS:
			{
				vtx0 = list_get(vtxgp->vertex_list, 0);
				vtx1 = list_get(vtxgp->vertex_list, 1);
				vtx2 = list_get(vtxgp->vertex_list, 2);
				vtx3 = list_get(vtxgp->vertex_list, 3);
				opengl_rasterizer_draw_triangle(opengl_ctx, vtx0, vtx1, vtx2);
				opengl_rasterizer_draw_triangle(opengl_ctx, vtx0, vtx2, vtx3);
				break;
			}
			case GL_QUAD_STRIP:
			{
				break;
			}
			case GL_POLYGON:
			{
				break;
			}
			default:
				break;
		}
	}

	/* Refresh host GLUT window */
	glut_frame_buffer_flush_request();	

	/* Clean old vertex buffer and create a new one */
	opengl_vertex_buffer_free(opengl_ctx->vertex_buffer);
	opengl_ctx->vertex_buffer = opengl_vertex_buffer_create();
	/* Return */
	return 0;	
}

/*
 * OpenGL call #14 - glColor3f
 *
 * glColor3f - set the current color
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glColor3f(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int args_ptr;
	int i;

	/* Read arguments */
	args_ptr = regs->ecx;
	opengl_debug("\targs_ptr=0x%x\n", args_ptr);

	/* Get function info */
	GLfloat func_args[4];
	mem_read(mem, args_ptr, 3 * sizeof(GLfloat), func_args);
	for (i = 0; i < 3; i++)
		opengl_debug("\t\targs[%d] = %f\n",
			i, func_args[i]);

	func_args[3] = 1.0f;

	/* Set the current color */
	opengl_clamped_float_to_color_channel(func_args, opengl_ctx->current_color);
	opengl_debug("\tCurrent Color RGBA [%d, %d, %d, %d]\n", 
				opengl_ctx->current_color[0],
				opengl_ctx->current_color[1],
				opengl_ctx->current_color[2],
				opengl_ctx->current_color[3]);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #15 - glLightfv
 *
 * glLightfv - set light source parameters
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glLightfv(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	struct opengl_light_t *lght;
	struct opengl_matrix_t *mtx;

	unsigned int args[3];
	unsigned int light;
	unsigned int pname;
	unsigned int params;

	/* Read arguments */
	mem_read(mem, regs->ecx, 3 * sizeof(unsigned int), args);
	light = args[0];
	pname = args[1];
	params = args[2];

	/* Copy */
	GLfloat *tmp_vctr;
	if (pname == GL_AMBIENT || pname == GL_DIFFUSE || pname == GL_SPECULAR || pname == GL_POSITION)
	{
		tmp_vctr = xcalloc(1, 4 * sizeof(GLfloat));
		mem_read(mem, params, 4 * sizeof(GLfloat), tmp_vctr);
	} 
	else if (pname == GL_SPOT_DIRECTION)
	{
		tmp_vctr = xcalloc(1, 4 * sizeof(GLfloat));
		mem_read(mem, params, 3 * sizeof(GLfloat), tmp_vctr);
	}
	else
	{
		tmp_vctr = xcalloc(1, sizeof(GLfloat));
		mem_read(mem, params, sizeof(GLfloat), tmp_vctr);
	}
	
	/* Get Light index */
	int lgt_idx = light % GL_LIGHT0;
	lght = 	opengl_ctx->light->Light[lgt_idx];

	/* Debug info */
	opengl_debug("\tSetting Light %d, Pname = 0x%x\n", lgt_idx, pname);

	int i;
	opengl_debug("\tParameters:");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug(" %f", tmp_vctr[i]);
	}
	opengl_debug("\n");

	/* Setting OpenGL lights */
	switch(pname)
	{
		case GL_AMBIENT:
		{
			memcpy(lght->Ambient, tmp_vctr, 4 * sizeof(GLfloat));
			opengl_debug("\tAmbient = [%f, %f, %f, %f]\n", lght->Ambient[0], lght->Ambient[1], lght->Ambient[2], lght->Ambient[3]);
			break;
		}
		case GL_DIFFUSE:
		{
			memcpy(lght->Diffuse, tmp_vctr, 4 * sizeof(GLfloat));
			opengl_debug("\tDiffuse = [%f, %f, %f, %f]\n", lght->Diffuse[0], lght->Diffuse[1], lght->Diffuse[2], lght->Diffuse[3]);
			break;
		}
		case GL_SPECULAR:
		{
			memcpy(lght->Specular, tmp_vctr, 4 * sizeof(GLfloat));
			opengl_debug("\tSpecular = [%f, %f, %f, %f]\n", lght->Specular[0], lght->Specular[1], lght->Specular[2], lght->Specular[3]);
			break;
		}
		case GL_POSITION:
		{
			/* Multiplied by ModelView matrix to translate to eye coordinate */
			mtx = opengl_matrix_stack_top(opengl_ctx->modelview_matrix_stack);
			opengl_matrix_vector_mul_matrix(tmp_vctr, mtx->matrix, tmp_vctr);
			memcpy(lght->EyePosition, tmp_vctr, 4 * sizeof(GLfloat));
			opengl_debug("\tEyePosition = [%f, %f, %f, %f]\n", lght->EyePosition[0], lght->EyePosition[1], lght->EyePosition[2], lght->EyePosition[3]);
			break;
		}
		case GL_SPOT_DIRECTION:
		{
			/* Multiplied by ModelView matrix to translate to eye coordinate */
			/* FIXME: invert or not ?*/
			mtx = opengl_matrix_stack_top(opengl_ctx->modelview_matrix_stack);
			if (opengl_matrix_is_dirty(mtx))
				opengl_matrix_analyse(mtx);
			opengl_matrix_vector_mul_matrix(tmp_vctr, mtx->matrix, tmp_vctr);
			memcpy(lght->SpotDirection, tmp_vctr, 4 * sizeof(GLfloat));
			opengl_debug("\tSpotDirection = [%f, %f, %f, %f]\n", lght->SpotDirection[0], lght->SpotDirection[1], lght->SpotDirection[2], lght->SpotDirection[3]);
			break;
		}
		case GL_SPOT_EXPONENT:
		{
			memcpy(&lght->SpotExponent, tmp_vctr, sizeof(GLfloat));
			opengl_debug("\tSpotExponent = [%f]\n", lght->SpotExponent);
			break;
		}
		case GL_SPOT_CUTOFF:
		{
			memcpy(&lght->SpotCutoff, tmp_vctr, sizeof(GLfloat));
			opengl_debug("\tSpotCutoff = [%f]\n", lght->SpotCutoff);
			break;
		}
		case GL_CONSTANT_ATTENUATION:
		{
			memcpy(&lght->ConstantAttenuation, tmp_vctr, sizeof(GLfloat));
			opengl_debug("\tConstantAttenuation = [%f]\n", lght->ConstantAttenuation);
			break;
		}
		case GL_LINEAR_ATTENUATION:
		{
			memcpy(&lght->LinearAttenuation, tmp_vctr, sizeof(GLfloat));
			opengl_debug("\tLinearAttenuation = [%f]\n", lght->LinearAttenuation);
			break;
		}
		case GL_QUADRATIC_ATTENUATION:
		{
			memcpy(&lght->QuadraticAttenuation, tmp_vctr, sizeof(GLfloat));
			opengl_debug("\tQuadraticAttenuation = [%f]\n", lght->QuadraticAttenuation);
			break;
		}
		default:
			break;
	}

	/* Free */
	free(tmp_vctr);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #16 - glGenLists
 *
 * glGenLists - generate a contiguous set of empty display lists.
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glGenLists(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int args[1];
	unsigned int range;

	/* Read arguments */
	mem_read(mem, regs->ecx, sizeof(unsigned int), args);
	range = args[0];

	opengl_debug("\tRange = %d\n", range);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #17 - glNewList
 *
 * glNewList - create or replace a display list
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glNewList(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int args[2];
	unsigned int list;
	unsigned int mode;

	/* Read arguments */
	mem_read(mem, regs->ecx, 2 * sizeof(unsigned int), args);
	list = args[0];
	mode = args[1];

	opengl_debug("\tList ID = %d, Mode = 0x%x\n", list, mode);


	/* Return */
	return 0;
}

/*
 * OpenGL call #18 - glEndList
 *
 * glEndList - create or replace a display list
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glEndList(struct x86_ctx_t *ctx)
{

	/* Return */
	return 0;	
}
/*
 * OpenGL call #19 - glMaterialfv
 *
 * glMaterialfv - specify material parameters for the lighting model
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glMaterialfv(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	GLfloat *mtrl_ptr;

	unsigned int args[3];
	unsigned int face;
	unsigned int pname;
	unsigned int params;

	/* Read arguments */
	mem_read(mem, regs->ecx, 3 * sizeof(unsigned int), args);
	face = args[0];
	pname = args[1];
	params = args[2];

	/* Copy */
	mtrl_ptr = xcalloc(1, 4 * sizeof(GLfloat));
	if (pname == GL_SHININESS)
		mem_read(mem, params, 1 * sizeof(GLfloat), mtrl_ptr);		
	else
		mem_read(mem, params, 4 * sizeof(GLfloat), mtrl_ptr);

	opengl_debug("\tface = 0x%x, pname = 0x%x\n", face, pname);

	/* Setup material */
	opengl_material_setup(opengl_ctx->light->Material, face, pname, mtrl_ptr);
	
	/* Free */
	free(mtrl_ptr);

	/* Return */
	return 0;
}

/*
 * OpenGL call #20 - glShadeModel
 *
 * glShadeModel - select flat or smooth shading
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glShadeModel(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int args[1];
	unsigned int mode;

	/* Read arguments */
	mem_read(mem, regs->ecx, 1 * sizeof(unsigned int), args);
	mode = args[0];

	/* Setup shade mode: FLAT or SMOOTH */
	opengl_ctx->light->ShadeModel = mode;

	opengl_debug("\tmode = 0x%x\n", mode);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #21 - glNormal3f
 *
 * glNormal3f - set the current normal vector
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glNormal3f(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	unsigned int args[3];
	GLfloat nx;
	GLfloat ny;
	GLfloat nz;

	/* Read arguments */
	mem_read(mem, regs->ecx, 3 * sizeof(GLfloat), args);
	nx = args[0];
	ny = args[1];
	nz = args[2];

	opengl_debug("\tnx =%f, ny = %f, nz = %f\n", nx, ny, nz);

	/* Set OpenGL context current normal */
	opengl_ctx->current_normal[0] = nx;
	opengl_ctx->current_normal[0] = ny;
	opengl_ctx->current_normal[0] = nz;
	opengl_ctx->current_normal[0] = 1.0f;

	/* Return */
	return 0;	
}

/*
 * OpenGL call #22 - glFrustum
 *
 * glFrustum - multiply the current matrix by a perspective matrix
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glFrustum(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	GLdouble args[6];

	int i;
	int j;

	/* Read arguments */
	mem_read(mem, regs->ecx, 6 * sizeof(GLdouble), args);

	struct opengl_matrix_t *mtx_frstm;
	struct opengl_matrix_t *mtx_curr;

	GLdouble left = args[0];
	GLdouble right = args[1];
	GLdouble bottom = args[2];
	GLdouble top = args[3];
	GLdouble nearval = args[4];
	GLdouble farval = args[5];

	opengl_debug("\targs = [%f, %f, %f, %f, %f, %f]\n", left, right, bottom, top, nearval, farval);

	/* Initialize frustum matrix */
	mtx_frstm = opengl_frustum_matrix_create(left, right, bottom, top, nearval, farval);

	opengl_debug("\t\tFrustum:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_frstm->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	mtx_curr = opengl_context_get_current_matrix(opengl_ctx);
	opengl_debug("\t\tCurr:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_curr->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	/* Current matrix multiplies perspective matrix */
	opengl_matrix_mul_matrix(mtx_curr, mtx_curr, mtx_frstm);
	opengl_debug("\t\tCurr x Frustum:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_curr->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	/* Free */
	opengl_frustum_matrix_free(mtx_frstm);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #23 - glTranslatef
 *
 * glTranslatef - multiply the current matrix by a translation matrix
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glTranslatef(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	struct opengl_matrix_t *mtx_trns;
	struct opengl_matrix_t *mtx_curr;

	GLfloat args[3];
	GLfloat x;
	GLfloat y;
	GLfloat z;

	int i;
	int j;

	/* Read arguments */
	mem_read(mem, regs->ecx, 3 * sizeof(GLfloat), args);
	x = args[0];
	y = args[1];
	z = args[2];
	opengl_debug("\tTranslate x = %f, y = %f, z = %f\n", x, y, z);

	/* Setup matrices */
	mtx_trns = opengl_translate_matrix_create(x, y, z);
	mtx_curr = opengl_context_get_current_matrix(opengl_ctx);

	opengl_debug("\t\tTranslate:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_trns->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	opengl_debug("\t\tCurr:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_curr->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}


	/* Multiply */
	opengl_matrix_mul_matrix(mtx_curr, mtx_curr, mtx_trns);

	opengl_debug("\t\tCurr x Translate:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_curr->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	/* Free */
	opengl_translate_matrix_free(mtx_trns);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #24 - glPushMatrix
 *
 * glPushMatrix - push the current matrix
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glPushMatrix(struct x86_ctx_t *ctx)
{
	struct opengl_matrix_t *mtx_curr;
	struct opengl_matrix_t *mtx_dulp;

	/* Duplicate current matrix then push it to current matrix stack */
	mtx_curr = opengl_context_get_current_matrix(opengl_ctx);
	opengl_debug("\t\tmtx_curr = %p, mtx_curr->matrix = %p\n", mtx_curr, mtx_curr->matrix );

	mtx_dulp = opengl_matrix_duplicate(mtx_curr);
	opengl_debug("\t\tmtx_dulp = %p, mtx_dulp->matix = %p\n", mtx_dulp, mtx_dulp->matrix );

	opengl_matrix_stack_push(opengl_ctx->current_matrix_stack, mtx_dulp);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #25 - glPopMatrix
 *
 * glPopMatrix - pop the current matrix
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glPopMatrix(struct x86_ctx_t *ctx)
{

	/* Pop matrix from current matrix stack */
	opengl_matrix_stack_pop(opengl_ctx->current_matrix_stack);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #26 - glRotatef
 *
 * glRotatef - multiply the current matrix by a rotation matrix
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glRotatef(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;
	struct opengl_matrix_t *mtx_rot;
	struct opengl_matrix_t *mtx_curr;

	GLfloat args[4];
	GLfloat angle;
	GLfloat x;
	GLfloat y;
	GLfloat z;

	int i;
	int j;

	/* Read arguments */
	mem_read(mem, regs->ecx, 4 * sizeof(GLfloat), args);
	angle = args[0];
	x = args[1];
	y = args[2];
	z = args[3];
	opengl_debug("\tRotate angle = %f, x = %f, y = %f, z = %f\n", angle, x, y, z);

	/* Setup matrices */
	mtx_rot = opengl_rotate_matrix_create(angle, x, y, z);
	mtx_curr = opengl_context_get_current_matrix(opengl_ctx);
	opengl_debug("\t\tRotate:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_rot->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	opengl_debug("\t\tCurr:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_curr->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	/* Multiply */
	opengl_matrix_mul_matrix(mtx_curr, mtx_curr, mtx_rot);
	opengl_debug("\t\tCurr x Rotate:\n");
	for (i = 0; i < 4; ++i)
	{
		opengl_debug("\t\t");
		for (j = 0; j < 4; ++j)
		{
			opengl_debug("%f\t", mtx_curr->matrix[j*4+i]);
		}
		opengl_debug("\n");
	}

	/* Free */
	opengl_rotate_matrix_free(mtx_rot);


	/* Return */
	return 0;	
}

/*
 * OpenGL call #27 - glCallList
 *
 * glCallList - executes a display list
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glCallList(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	GLuint args[1];
	GLuint list;

	/* Read arguments */
	mem_read(mem, regs->ecx, 1 * sizeof(GLuint), args);
	list = args[0];

	opengl_debug("\tCalling list =%d\n", list);

	/* Return */
	return 0;	
}

/*
 * OpenGL call #28 - glClearColor
 *
 * glClearColor - specify clear values for the color buffers
 *
 * @return
 *	The function always returns 0
 */

static int opengl_func_glClearColor(struct x86_ctx_t *ctx)
{
	struct x86_regs_t *regs = ctx->regs;
	struct mem_t *mem = ctx->mem;

	GLfloat args[4];
	GLfloat red;
	GLfloat green;
	GLfloat blue;
	GLfloat alpha;

	/* Read arguments */
	mem_read(mem, regs->ecx, 4 * sizeof(GLfloat), args);
	red = args[0];
	green = args[1];
	blue = args[2];
	alpha = args[3];

	opengl_debug("\tClear color: RGBA = [%f, %f, %f, %f]\n", red, green, blue, alpha);

	/* Set clear color */

	/* Return */
	return 0;	
}
