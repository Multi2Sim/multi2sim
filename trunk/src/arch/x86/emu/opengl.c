/*
 *  Multi2Sim
 *  Copyright (C) 2011  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <x86-emu.h>
#include <mem-system.h>
#include <GL/gl.h>

static char *err_x86_opengl_code =
	"\tAn invalid function code was generated by your application in a OpenGL system\n"
	"\tcall. Probably, this means that your application is using an incompatible\n"
	"\tversion of the Multi2Sim OpenGL runtime library ('libm2s-opengl'). Please\n"
	"\trecompile your application and try again.\n";


/* Debug */
int x86_opengl_debug_category;


/* List of OPENGL runtime calls */
enum x86_opengl_call_t
{
	x86_opengl_call_invalid = 0,
#define X86_OPENGL_DEFINE_CALL(name, code) x86_opengl_call_##name = code,
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL
	x86_opengl_call_count
};


/* List of OPENGL runtime call names */
char *x86_opengl_call_name[x86_opengl_call_count + 1] =
{
	NULL,
#define X86_OPENGL_DEFINE_CALL(name, code) #name,
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL
	NULL
};


/* Forward declarations of OPENGL runtime functions */
#define X86_OPENGL_DEFINE_CALL(name, code) static int x86_opengl_func_##name(void);
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL


/* List of OPENGL runtime functions */
typedef int (*x86_opengl_func_t)(void);
static x86_opengl_func_t x86_opengl_func_table[x86_opengl_call_count + 1] =
{
	NULL,
#define X86_OPENGL_DEFINE_CALL(name, code) x86_opengl_func_##name,
#include "opengl.dat"
#undef X86_OPENGL_DEFINE_CALL
	NULL
};


/*
 * OpenGL structures
 */

/* OpenGL context capability */
struct x86_opengl_context_t_capability_t
{
	GLboolean is_alpha_test;
	GLboolean is_auto_normal;
	GLboolean is_blend;
	GLboolean is_clip_plane0;
	GLboolean is_clip_plane1;
	GLboolean is_clip_plane2;
	GLboolean is_clip_plane3;
	GLboolean is_clip_plane4;
	GLboolean is_clip_plane5;
	GLboolean is_color_logic_op;
	GLboolean is_color_material;
	GLboolean is_color_sum;
	GLboolean is_color_table;
	GLboolean is_convolution_1d;
	GLboolean is_convolution_2d;
	GLboolean is_cull_face;
	GLboolean is_depth_test;
	GLboolean is_dither;
	GLboolean is_fog;
	GLboolean is_histogram;
	GLboolean is_index_logic_op;
	GLboolean is_light0;
	GLboolean is_light1;
	GLboolean is_light2;
	GLboolean is_light3;
	GLboolean is_light4;
	GLboolean is_light5;
	GLboolean is_light6;
	GLboolean is_light7;
	GLboolean is_lighting;
	GLboolean is_line_smooth;
	GLboolean is_line_stipple;
	GLboolean is_map1_color_4;
	GLboolean is_map1_index;
	GLboolean is_map1_normal;
	GLboolean is_map1_texture_coord_1;
	GLboolean is_map1_texture_coord_2;
	GLboolean is_map1_texture_coord_3;
	GLboolean is_map1_texture_coord_4;
	GLboolean is_map1_vertex_3;
	GLboolean is_map1_vertex_4;
	GLboolean is_map2_color_4;
	GLboolean is_map2_index;
	GLboolean is_map2_normal;
	GLboolean is_map2_texture_coord_1;
	GLboolean is_map2_texture_coord_2;
	GLboolean is_map2_texture_coord_3;
	GLboolean is_map2_texture_coord_4;
	GLboolean is_map2_vertex_3;
	GLboolean is_map2_vertex_4;
	GLboolean is_minmax;
	GLboolean is_multisample;
	GLboolean is_normalize;
	GLboolean is_point_smooth;
	GLboolean is_point_sprite;
	GLboolean is_polygon_offset_fill;
	GLboolean is_polygon_offset_line;
	GLboolean is_polygon_offset_point;
	GLboolean is_polygon_smooth;
	GLboolean is_polygon_stipple;
	GLboolean is_post_color_matrix_color_table;
	GLboolean is_post_convolution_color_table;
	GLboolean is_rescale_normal;
	GLboolean is_sample_alpha_to_coverage;
	GLboolean is_sample_alpha_to_one;
	GLboolean is_sample_coverage;
	GLboolean is_separable_2d;
	GLboolean is_scissor_test;
	GLboolean is_stencil_test;
	GLboolean is_texture_1d;
	GLboolean is_texture_2d;
	GLboolean is_texture_3d;
	GLboolean is_texture_cube_map;
	GLboolean is_texture_gen_q;
	GLboolean is_texture_gen_r;
	GLboolean is_texture_gen_s;
	GLboolean is_texture_gen_t;
	GLboolean is_vertex_program_point_size;
	GLboolean is_vertex_program_two_side;
};

/* OpenGL frame buffer */
struct x86_opengl_frame_buffer_t
{
	GLsizei width;
	GLsizei height;

	GLuint *buffer;
};

/* OpenGL Viewport attribute */
struct x86_opengl_viewport_attributes_t
{
	/* Position */
	GLint x;
	GLint y;
	/* Size */
	GLsizei width;
	GLsizei height;

	/* FIXME: also found below in Mesa */
	/* Depth buffer range */
	// GLfloat Near;
	// GLfloat Far;

	/* Mapping transformation as a matrix. */
	// GLmatrix _WindowMap; 
};

/* OpenGL: Different kinds of 4x4 transformation matrices */
enum x86_opengl_matrix_mode_t {
	MATRIX_GENERAL,		/* general 4x4 matrix */
	MATRIX_IDENTITY,		/* identity matrix */
	MATRIX_3D_NO_ROT,	/* orthogonal projection and others... */
	MATRIX_PERSPECTIVE,	/* perspective projection matrix */
	MATRIX_2D,			/* 2-D transformation */
	MATRIX_2D_NO_ROT,	/* 2-D scale & translate only */
	MATRIX_3D			/* 3-D transformation */
} ;

/* OpenGL identity matrix */
static GLfloat Identity[16] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
};

/* OpenGL Matrix */
struct x86_opengl_matrix_t
{
	GLfloat *matrix;	/* Points to 4x4 GLfloat type arrays*/
	enum x86_opengl_matrix_mode_t matrix_mode;	
};

/* OpenGL Matrix Stack */
struct x86_opengl_matrix_stack_t
{
	struct list_t *stack;
	GLuint depth;
	GLuint max_depth;
};


struct x86_opengl_matrix_t *x86_opengl_matrix_create(enum x86_opengl_matrix_mode_t mode)
{
	struct x86_opengl_matrix_t *mtx;

	/* Allocate */
	mtx = calloc(1, sizeof(struct x86_opengl_matrix_t));
	if(!mtx)
		fatal("%s: out of memory", __FUNCTION__);

	/* Initialize */
	mtx->matrix_mode = mode;
	mtx->matrix = calloc(1, 4*4*sizeof(GLfloat));	/* 4x4 matrix */
	switch(mode)
	{
		case MATRIX_IDENTITY:
		{
			memcpy( mtx->matrix, Identity, sizeof(Identity));
			break;
		}
		default:
			break;
	}

	/* Return */	
	return mtx;
}

void x86_opengl_matrix_free(struct x86_opengl_matrix_t *mtx)
{
	free(mtx->matrix);
	free(mtx);
}

/* Maximum modelview matrix stack depth */
#define MAX_MODELVIEW_STACK_DEPTH 32

/* Maximum projection matrix stack depth */
#define MAX_PROJECTION_STACK_DEPTH 32

/* Maximum texture matrix stack depth */
#define MAX_TEXTURE_STACK_DEPTH 10

/* FIXME: Maximum color matrix stack depth */ 
#define MAX_COLOR_STACK_DEPTH 32

struct x86_opengl_matrix_stack_t *x86_opengl_matrix_stack_create(GLenum mode)
{
	struct x86_opengl_matrix_stack_t *stack;
	struct x86_opengl_matrix_t *mtx;

	/* Allocate */
	stack = calloc(1, sizeof(struct x86_opengl_matrix_stack_t));
	if(!stack)
		fatal("%s: out of memory", __FUNCTION__);

	mtx = x86_opengl_matrix_create(MATRIX_GENERAL);

	/* Initialize */
	stack->stack = list_create();
	list_add(stack->stack, mtx);
	stack->depth = 1;

	switch (mode)
	{

	case GL_MODELVIEW:
	{
		stack->max_depth = MAX_MODELVIEW_STACK_DEPTH;
		break;
	}

	case GL_PROJECTION:
	{
		stack->max_depth = MAX_PROJECTION_STACK_DEPTH;
		break;
	}

	case GL_TEXTURE:
	{
		stack->max_depth = MAX_TEXTURE_STACK_DEPTH;
		break;
	}

	case GL_COLOR:
	{
		stack->max_depth = MAX_COLOR_STACK_DEPTH;
		break;
	}

	default:
		break;
	} 

	/* Return */	
	return stack;
}

void x86_opengl_matrix_stack_free(struct x86_opengl_matrix_stack_t *mtx_stack)
{
	/* Free matrices in the list */
	while (list_count(mtx_stack->stack))
		x86_opengl_matrix_free(list_remove_at(mtx_stack->stack, 0));
	/* Free list */
	list_free(mtx_stack->stack);
	/* Free stack */
	free(mtx_stack);
}

int x86_opengl_matrix_stack_push(struct x86_opengl_matrix_stack_t *mtx_stack, void *mtx)
{
	mtx_stack->depth += 1;
	if (mtx_stack->depth > mtx_stack->max_depth)
		fatal("Stack overflow, max depth = %d\n", mtx_stack->max_depth);
	list_push(mtx_stack->stack, mtx);
	return 0;
}

struct x86_opengl_matrix_t *x86_opengl_matrix_stack_pop(struct x86_opengl_matrix_stack_t *mtx_stack)
{
	/* Variables */
	struct x86_opengl_matrix_t *mtx;
	/* Pop from stack */
	mtx_stack->depth -= 1;
	if (mtx_stack->depth < 0 )
		fatal("Stack underflow, max depth = %d\n", mtx_stack->max_depth);
	mtx = list_pop(mtx_stack->stack);
	if (mtx == NULL)
		fatal("Empty stack!\n");
	/* Return */
	return mtx;
}

struct x86_opengl_matrix_t *x86_opengl_matrix_stack_pop_and_free(struct x86_opengl_matrix_stack_t *mtx_stack)
{
	/* Variables */
	struct x86_opengl_matrix_t *mtx;
	/* Pop from stack and free */
	mtx_stack->depth -= 1;
	if (mtx_stack->depth < 0)
		fatal("Stack underflow, max depth = %d\n", mtx_stack->max_depth);
	mtx = list_pop(mtx_stack->stack);
	if (mtx == NULL)
		fatal("Empty stack!\n");
	x86_opengl_matrix_free(mtx);
	/* Return */
	return mtx;
}

/* From config.h in Mesa */
#define MAX_TEXTURE_COORD_UNITS 8
#define MAX_TEXTURE_IMAGE_UNITS 16
#define MAX_TEXTURE_UNITS ((MAX_TEXTURE_COORD_UNITS > MAX_TEXTURE_IMAGE_UNITS) ? MAX_TEXTURE_COORD_UNITS : MAX_TEXTURE_IMAGE_UNITS)

/* OpenGL context*/
struct x86_opengl_context_t
{
	struct x86_opengl_context_t_capability_t *context_cap;					/* context capabilities */

	struct x86_opengl_frame_buffer_t *draw_buffer;						/* buffer for writing */
	struct x86_opengl_frame_buffer_t *read_buffer;						/* buffer for reading */

	struct x86_opengl_viewport_attributes_t *viewport;						/* viewport attributes */

	struct x86_opengl_matrix_stack_t *modelview_matrix_stack;					/* modelview matrix stack */
	struct x86_opengl_matrix_stack_t *projection_matrix_stack;					/* projection matrix stack */
	struct x86_opengl_matrix_stack_t *texture_matrix_stack[MAX_TEXTURE_UNITS];		/* texture matrix stacks */
	struct x86_opengl_matrix_stack_t *color_matrix_stack;					/* color matrix stack */
	struct x86_opengl_matrix_stack_t *current_matrix_stack;					/* current matrix stack, points to one of above stacks */

};


/*
 * OpenGL global variables
 */

/* OpenGL Context */
struct x86_opengl_context_t *x86_opengl_ctx;

/*
 * OpenGL Initialization
 */

struct x86_opengl_context_t_capability_t *x86_opengl_context_t_capability_create(void)
{
	/* Variables */
 	struct x86_opengl_context_t_capability_t* cap;

 	cap = calloc(1, sizeof(struct x86_opengl_context_t_capability_t));
	if (!cap)
		fatal("%s: out of memory", __FUNCTION__);

	/* Set up initial value for each capability, initial value for each capability is GL_FALSE, except GL_DITHER and GL_MULTISAMPLE */
	memset(cap, 0, sizeof(struct x86_opengl_context_t_capability_t));
	cap->is_dither = GL_TRUE;
	cap->is_multisample = GL_TRUE;

	/* Return */
	return cap;
}

void x86_opengl_context_t_capability_free(struct x86_opengl_context_t_capability_t *cap)
{
	free(cap);
}

struct x86_opengl_frame_buffer_t *x86_opengl_frame_buffer_create(int width, int height)
{
	/* Variables */
	struct x86_opengl_frame_buffer_t *fb;

	/* Allocate */
	fb = calloc(1, sizeof(struct x86_opengl_frame_buffer_t));
	if(!fb)
		fatal("%s: out of memory", __FUNCTION__);

	/* Initialization */
	fb->width = width;
	fb->height = height;
	fb->buffer = calloc(1, sizeof(GLuint)*width*height);

	/* Return */
	return fb;
}

void x86_opengl_frame_buffer_free(struct x86_opengl_frame_buffer_t *fb)
{
	free(fb->buffer);
	free(fb);
}

struct x86_opengl_viewport_attributes_t *x86_opengl_viewport_attributes_create(void)
{
	int width;
	int height;
	
	/* Variables */
	struct x86_opengl_viewport_attributes_t *vpt;

	/* Allocate */
	vpt = calloc(1, sizeof(struct x86_opengl_viewport_attributes_t));
	if(!vpt)
		fatal("%s: out of memory", __FUNCTION__);


	/* Initialize */
	width = 0;  // FIXME
	height = 0;  // FIXME
	//x86_glut_frame_buffer_get_size(&width, &height);
	/* RAFA - see related note below */

	vpt->x = 0;
	vpt->y = 0;
	vpt->width = width;
	vpt->height = height;

	/* Return */	
	return vpt;
}

void x86_opengl_viewport_free(struct x86_opengl_viewport_attributes_t *vpt)
{
	free(vpt);
}

struct x86_opengl_context_t *x86_opengl_context_create(void)
{
	/* Variables */
	int width;
	int height;
	int i;

	/* Allocate */
	struct x86_opengl_context_t *ctx;
	ctx = calloc(1, sizeof(struct x86_opengl_context_t));
	if(!ctx)
		fatal("%s: out of memory", __FUNCTION__);

	/* Initialize */

	/* Initialize frame buffers */
	//x86_glut_frame_buffer_get_size(&width, &height);
	width = 0;  // FIXME
	height = 0;  // FIXME
	/* RAFA - Xiang, we shouldn't call any GLUT function in the
	 * initialization of the simulator. Notice that the user may or may not
	 * have the GLUT library installed. If he doesn't, the GLUT functions
	 * defined in 'x86-emu.h' will cause an error message. This should only
	 * happen when the user is actually trying to run a GLUT application.
	 * This means that we need to call only frame buffer functions after an
	 * initialization call to OpenGL. Is this possible?
	 */
	/* To test how your code behaves when GLUT is not installed in your
	 * system, you can add line "have_glut=no" in the 'configure.ac' file,
	 * right before line
	 	if test x$have_glut == xno; then
	 * You don't need to actually keep installing and uninstalling the
	 * library.
	 */
	/* Temporary, I commented out the call to 'x86_glut_frame_buffer_get_size'
	 * and set width and height to 0. */
	ctx->draw_buffer = x86_opengl_frame_buffer_create(width, height);
	ctx->read_buffer = x86_opengl_frame_buffer_create(width, height);
	
	/* Initialize context capabilities */
	ctx->context_cap = x86_opengl_context_t_capability_create();

	/* Initialize viewport */
	ctx->viewport = x86_opengl_viewport_attributes_create();

	/* Initialize matrix stack */
	ctx->modelview_matrix_stack = x86_opengl_matrix_stack_create(GL_MODELVIEW);
	ctx->projection_matrix_stack = x86_opengl_matrix_stack_create(GL_PROJECTION);
	for (i = 0; i < MAX_TEXTURE_STACK_DEPTH; i++)
	{
		ctx->texture_matrix_stack[i] = x86_opengl_matrix_stack_create(GL_TEXTURE);
	}
	ctx->color_matrix_stack = x86_opengl_matrix_stack_create(GL_COLOR);
	/* FIXME: which one is the default current stack ? */
	ctx->current_matrix_stack = ctx->modelview_matrix_stack;

	/* Return */
	return ctx;
}

void x86_opengl_context_free(struct x86_opengl_context_t *ctx)
{
	/* Variables */
	int i;

	/* Free context capabilities*/
	x86_opengl_context_t_capability_free(ctx->context_cap);

	/* Free framebuffers */
	x86_opengl_frame_buffer_free(ctx->draw_buffer);
	x86_opengl_frame_buffer_free(ctx->read_buffer);

	/* Free viewport */
	x86_opengl_viewport_free(ctx->viewport);

	/* Free matrix stacks */
	x86_opengl_matrix_stack_free(ctx->modelview_matrix_stack);
	x86_opengl_matrix_stack_free(ctx->projection_matrix_stack);
	for (i = 0; i < MAX_TEXTURE_STACK_DEPTH; i++)
	{
		x86_opengl_matrix_stack_free(ctx->texture_matrix_stack[i]);	
	}
	x86_opengl_matrix_stack_free(ctx->color_matrix_stack);

	free(ctx);
}

void x86_opengl_init(void)
{
	x86_opengl_ctx = x86_opengl_context_create();
}


void x86_opengl_done(void)
{
	if (x86_opengl_ctx != NULL)
		x86_opengl_context_free(x86_opengl_ctx);
}


int x86_opengl_call(void)
{
	/* Variables */
	int code;
	int ret;

	/* Function code */
	code = x86_isa_regs->ebx;
	if (code <= x86_opengl_call_invalid || code >= x86_opengl_call_count)
		fatal("%s: invalid OpenGL function (code %d).\n%s",
			__FUNCTION__, code, err_x86_opengl_code);

	/* Debug */
	x86_opengl_debug("OpenGL runtime call '%s' (code %d)\n",
		x86_opengl_call_name[code], code);

	/* Call OPENGL function */
	assert(x86_opengl_func_table[code]);
	ret = x86_opengl_func_table[code]();

	/* Return value */
	return ret;
}

/*
 * OpenGL call #1 - glDrawBuffer
 *
 * glDrawBuffer - specify which color buffers are to be drawn into
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glDrawBuffer(void)
{
	/* Variables */
	unsigned int mode_ptr;

	/* Read arguments */
	mode_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tmode_ptr=0x%x\n", mode_ptr);

	GLenum mode;

	mem_read(x86_isa_mem, mode_ptr, sizeof(GLenum), &mode);

	/* Set color buffers */
	fatal("Not implemented yet!\n");

	/* Return success */
	return 0;
}


/*
 * OpenGL call #2 - glReadBuffer
 *
 * glReadBuffer - select a color buffer source for pixels
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glReadBuffer(void)
{
	/* Variables */
	unsigned int mode_ptr;

	/* Read arguments */
	mode_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tmode_ptr=0x%x\n", mode_ptr);

	GLenum mode;
	mem_read(x86_isa_mem, mode_ptr, sizeof(GLenum), &mode);

	/* Set color buffers */
	fatal("Not implemented yet!\n");

	/* Return success */
	return 0;
}
/*
 * OpenGL call #3 - glEnable
 *
 * glEnable - enable server-side GL capabilities
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glEnable(void)
{
	/* Variables */
	unsigned int cap_ptr;

	/* Read arguments */
	cap_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tcap_ptr=0x%x\n", cap_ptr);

	GLenum cap;

	mem_read(x86_isa_mem, cap_ptr, sizeof(GLenum), &cap);

	switch(cap)
	{

	case GL_ALPHA_TEST:

		{
			x86_opengl_ctx->context_cap->is_alpha_test = GL_TRUE;
			x86_opengl_debug("\tGL_ALPHA_TEST enabled!\n");
			break;
		}

	case GL_AUTO_NORMAL:

		{
			x86_opengl_ctx->context_cap->is_auto_normal = GL_TRUE;
			x86_opengl_debug("\tGL_AUTO_NORMAL enabled!\n");
			break;
		}

	case GL_BLEND:

		{
			x86_opengl_ctx->context_cap->is_blend = GL_TRUE;
			x86_opengl_debug("\tGL_BLEND enabled!\n");
			break;
		}

	case GL_CLIP_PLANE0:

		{
			x86_opengl_ctx->context_cap->is_clip_plane0 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE0 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE1:

		{
			x86_opengl_ctx->context_cap->is_clip_plane1 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE1 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE2:

		{
			x86_opengl_ctx->context_cap->is_clip_plane2 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE2 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE3:

		{
			x86_opengl_ctx->context_cap->is_clip_plane3 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE3 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE4:

		{
			x86_opengl_ctx->context_cap->is_clip_plane4 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE4 enabled!\n");
			break;
		}

	case GL_CLIP_PLANE5:

		{
			x86_opengl_ctx->context_cap->is_clip_plane5 = GL_TRUE;
			x86_opengl_debug("\tGL_CLIP_PLANE5 enabled!\n");
			break;
		}

	case GL_COLOR_LOGIC_OP:

		{
			x86_opengl_ctx->context_cap->is_color_logic_op = GL_TRUE;
			x86_opengl_debug("\tGL_COLOR_LOGIC_OP enabled!\n");
			break;
		}

	case GL_COLOR_MATERIAL:

		{
			x86_opengl_ctx->context_cap->is_color_material = GL_TRUE;
			x86_opengl_debug("\tGL_COLOR_MATERIAL enabled!\n");
			break;
		}

	case GL_COLOR_SUM:

		{
			x86_opengl_ctx->context_cap->is_color_sum = GL_TRUE;
			x86_opengl_debug("\tGL_COLOR_SUM enabled!\n");
			break;
		}

	case GL_COLOR_TABLE:

		{
			x86_opengl_ctx->context_cap->is_color_table = GL_TRUE;
			x86_opengl_debug("\tGL_COLOR_TABLE enabled!\n");
			break;
		}

	case GL_CONVOLUTION_1D:

		{
			x86_opengl_ctx->context_cap->is_convolution_1d = GL_TRUE;
			x86_opengl_debug("\tGL_CONVOLUTION_1D enabled!\n");
			break;
		}

	case GL_CONVOLUTION_2D:

		{
			x86_opengl_ctx->context_cap->is_convolution_2d = GL_TRUE;
			x86_opengl_debug("\tGL_CONVOLUTION_2D enabled!\n");
			break;
		}

	case GL_CULL_FACE:

		{
			x86_opengl_ctx->context_cap->is_cull_face = GL_TRUE;
			x86_opengl_debug("\tGL_CULL_FACE enabled!\n");
			break;
		}

	case GL_DEPTH_TEST:

		{
			x86_opengl_ctx->context_cap->is_depth_test = GL_TRUE;
			x86_opengl_debug("\tGL_DEPTH_TEST enabled!\n");
			break;
		}

	case GL_DITHER:

		{
			x86_opengl_ctx->context_cap->is_dither = GL_TRUE;
			x86_opengl_debug("\tGL_DITHER enabled!\n");
			break;
		}

	case GL_FOG:

		{
			x86_opengl_ctx->context_cap->is_fog = GL_TRUE;
			x86_opengl_debug("\tGL_FOG enabled!\n");
			break;
		}

	case GL_HISTOGRAM:

		{
			x86_opengl_ctx->context_cap->is_histogram = GL_TRUE;
			x86_opengl_debug("\tGL_HISTOGRAM enabled!\n");
			break;
		}

	case GL_INDEX_LOGIC_OP:

		{
			x86_opengl_ctx->context_cap->is_index_logic_op = GL_TRUE;
			x86_opengl_debug("\tGL_INDEX_LOGIC_OP enabled!\n");
			break;
		}

	case GL_LIGHT0:

		{
			x86_opengl_ctx->context_cap->is_light0 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT0 enabled!\n");
			break;
		}

	case GL_LIGHT1:

		{
			x86_opengl_ctx->context_cap->is_light1 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT1 enabled!\n");
			break;
		}

	case GL_LIGHT2:

		{
			x86_opengl_ctx->context_cap->is_light2 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT2 enabled!\n");
			break;
		}

	case GL_LIGHT3:

		{
			x86_opengl_ctx->context_cap->is_light3 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT3 enabled!\n");
			break;
		}

	case GL_LIGHT4:

		{
			x86_opengl_ctx->context_cap->is_light4 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT4 enabled!\n");
			break;
		}

	case GL_LIGHT5:

		{
			x86_opengl_ctx->context_cap->is_light5 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT5 enabled!\n");
			break;
		}

	case GL_LIGHT6:

		{
			x86_opengl_ctx->context_cap->is_light6 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT6 enabled!\n");
			break;
		}

	case GL_LIGHT7:

		{
			x86_opengl_ctx->context_cap->is_light7 = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHT7 enabled!\n");
			break;
		}

	case GL_LIGHTING:

		{
			x86_opengl_ctx->context_cap->is_lighting = GL_TRUE;
			x86_opengl_debug("\tGL_LIGHTING enabled!\n");
			break;
		}

	case GL_LINE_SMOOTH:

		{
			x86_opengl_ctx->context_cap->is_line_smooth = GL_TRUE;
			x86_opengl_debug("\tGL_LINE_SMOOTH enabled!\n");
			break;
		}

	case GL_LINE_STIPPLE:

		{
			x86_opengl_ctx->context_cap->is_line_stipple = GL_TRUE;
			x86_opengl_debug("\tGL_LINE_STIPPLE enabled!\n");
			break;
		}

	case GL_MAP1_COLOR_4:

		{
			x86_opengl_ctx->context_cap->is_map1_color_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_COLOR_4 enabled!\n");
			break;
		}

	case GL_MAP1_INDEX:

		{
			x86_opengl_ctx->context_cap->is_map1_index = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_INDEX enabled!\n");
			break;
		}

	case GL_MAP1_NORMAL:

		{
			x86_opengl_ctx->context_cap->is_map1_normal = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_NORMAL enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_1:

		{
			x86_opengl_ctx->context_cap->is_map1_texture_coord_1 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_TEXTURE_COORD_1 enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_2:

		{
			x86_opengl_ctx->context_cap->is_map1_texture_coord_2 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_TEXTURE_COORD_2 enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_3:

		{
			x86_opengl_ctx->context_cap->is_map1_texture_coord_3 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_TEXTURE_COORD_3 enabled!\n");
			break;
		}

	case GL_MAP1_TEXTURE_COORD_4:

		{
			x86_opengl_ctx->context_cap->is_map1_texture_coord_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_TEXTURE_COORD_4 enabled!\n");
			break;
		}

	case GL_MAP1_VERTEX_3:

		{
			x86_opengl_ctx->context_cap->is_map1_vertex_3 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_VERTEX_3 enabled!\n");
			break;
		}

	case GL_MAP1_VERTEX_4:

		{
			x86_opengl_ctx->context_cap->is_map1_vertex_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP1_VERTEX_4 enabled!\n");
			break;
		}

	case GL_MAP2_COLOR_4:

		{
			x86_opengl_ctx->context_cap->is_map2_color_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_COLOR_4 enabled!\n");
			break;
		}

	case GL_MAP2_INDEX:

		{
			x86_opengl_ctx->context_cap->is_map2_index = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_INDEX enabled!\n");
			break;
		}

	case GL_MAP2_NORMAL:

		{
			x86_opengl_ctx->context_cap->is_map2_normal = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_NORMAL enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_1:

		{
			x86_opengl_ctx->context_cap->is_map2_texture_coord_1 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_TEXTURE_COORD_1 enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_2:

		{
			x86_opengl_ctx->context_cap->is_map2_texture_coord_2 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_TEXTURE_COORD_2 enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_3:

		{
			x86_opengl_ctx->context_cap->is_map2_texture_coord_3 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_TEXTURE_COORD_3 enabled!\n");
			break;
		}

	case GL_MAP2_TEXTURE_COORD_4:

		{
			x86_opengl_ctx->context_cap->is_map2_texture_coord_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_TEXTURE_COORD_4 enabled!\n");
			break;
		}

	case GL_MAP2_VERTEX_3:

		{
			x86_opengl_ctx->context_cap->is_map2_vertex_3 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_VERTEX_3 enabled!\n");
			break;
		}

	case GL_MAP2_VERTEX_4:

		{
			x86_opengl_ctx->context_cap->is_map2_vertex_4 = GL_TRUE;
			x86_opengl_debug("\tGL_MAP2_VERTEX_4 enabled!\n");
			break;
		}

	case GL_MINMAX:

		{
			x86_opengl_ctx->context_cap->is_minmax = GL_TRUE;
			x86_opengl_debug("\tGL_MINMAX enabled!\n");
			break;
		}

	case GL_MULTISAMPLE:

		{
			x86_opengl_ctx->context_cap->is_multisample = GL_TRUE;
			x86_opengl_debug("\tGL_MULTISAMPLE enabled!\n");
			break;
		}

	case GL_NORMALIZE:

		{
			x86_opengl_ctx->context_cap->is_normalize = GL_TRUE;
			x86_opengl_debug("\tGL_NORMALIZE enabled!\n");
			break;
		}

	case GL_POINT_SMOOTH:

		{
			x86_opengl_ctx->context_cap->is_point_smooth = GL_TRUE;
			x86_opengl_debug("\tGL_POINT_SMOOTH enabled!\n");
			break;
		}

	case GL_POINT_SPRITE:

		{
			x86_opengl_ctx->context_cap->is_point_sprite = GL_TRUE;
			x86_opengl_debug("\tGL_POINT_SPRITE enabled!\n");
			break;
		}

	case GL_POLYGON_OFFSET_FILL:

		{
			x86_opengl_ctx->context_cap->is_polygon_offset_fill = GL_TRUE;
			x86_opengl_debug("\tGL_POLYGON_OFFSET_FILL enabled!\n");
			break;
		}

	case GL_POLYGON_OFFSET_LINE:

		{
			x86_opengl_ctx->context_cap->is_polygon_offset_line = GL_TRUE;
			x86_opengl_debug("\tGL_POLYGON_OFFSET_LINE enabled!\n");
			break;
		}

	case GL_POLYGON_OFFSET_POINT:

		{
			x86_opengl_ctx->context_cap->is_polygon_offset_point = GL_TRUE;
			x86_opengl_debug("\tGL_POLYGON_OFFSET_POINT enabled!\n");
			break;
		}

	case GL_POLYGON_SMOOTH:

		{
			x86_opengl_ctx->context_cap->is_polygon_smooth = GL_TRUE;
			x86_opengl_debug("\tGL_POLYGON_SMOOTH enabled!\n");
			break;
		}

	case GL_POLYGON_STIPPLE:

		{
			x86_opengl_ctx->context_cap->is_polygon_stipple = GL_TRUE;
			x86_opengl_debug("\tGL_POLYGON_STIPPLE enabled!\n");
			break;
		}

	case GL_POST_COLOR_MATRIX_COLOR_TABLE:

		{
			x86_opengl_ctx->context_cap->is_post_color_matrix_color_table = GL_TRUE;
			x86_opengl_debug("\tGL_POST_COLOR_MATRIX_COLOR_TABLE enabled!\n");
			break;
		}

	case GL_POST_CONVOLUTION_COLOR_TABLE:

		{
			x86_opengl_ctx->context_cap->is_post_convolution_color_table = GL_TRUE;
			x86_opengl_debug("\tGL_POST_CONVOLUTION_COLOR_TABLE enabled!\n");
			break;
		}

	case GL_RESCALE_NORMAL:

		{
			x86_opengl_ctx->context_cap->is_rescale_normal = GL_TRUE;
			x86_opengl_debug("\tGL_RESCALE_NORMAL enabled!\n");
			break;
		}

	case GL_SAMPLE_ALPHA_TO_COVERAGE:

		{
			x86_opengl_ctx->context_cap->is_sample_alpha_to_coverage = GL_TRUE;
			x86_opengl_debug("\tGL_SAMPLE_ALPHA_TO_COVERAGE enabled!\n");
			break;
		}

	case GL_SAMPLE_ALPHA_TO_ONE:

		{
			x86_opengl_ctx->context_cap->is_sample_alpha_to_one = GL_TRUE;
			x86_opengl_debug("\tGL_SAMPLE_ALPHA_TO_ONE enabled!\n");
			break;
		}

	case GL_SAMPLE_COVERAGE:

		{
			x86_opengl_ctx->context_cap->is_sample_coverage = GL_TRUE;
			x86_opengl_debug("\tGL_SAMPLE_COVERAGE enabled!\n");
			break;
		}

	case GL_SEPARABLE_2D:

		{
			x86_opengl_ctx->context_cap->is_separable_2d = GL_TRUE;
			x86_opengl_debug("\tGL_SEPARABLE_2D enabled!\n");
			break;
		}

	case GL_SCISSOR_TEST:

		{
			x86_opengl_ctx->context_cap->is_scissor_test = GL_TRUE;
			x86_opengl_debug("\tGL_SCISSOR_TEST enabled!\n");
			break;
		}

	case GL_STENCIL_TEST:

		{
			x86_opengl_ctx->context_cap->is_stencil_test = GL_TRUE;
			x86_opengl_debug("\tGL_STENCIL_TEST enabled!\n");
			break;
		}

	case GL_TEXTURE_1D:

		{
			x86_opengl_ctx->context_cap->is_texture_1d = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_1D enabled!\n");
			break;
		}

	case GL_TEXTURE_2D:

		{
			x86_opengl_ctx->context_cap->is_texture_2d = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_2D enabled!\n");
			break;
		}

	case GL_TEXTURE_3D:

		{
			x86_opengl_ctx->context_cap->is_texture_3d = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_3D enabled!\n");
			break;
		}

	case GL_TEXTURE_CUBE_MAP:

		{
			x86_opengl_ctx->context_cap->is_texture_cube_map = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_CUBE_MAP enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_Q:

		{
			x86_opengl_ctx->context_cap->is_texture_gen_q = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_GEN_Q enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_R:

		{
			x86_opengl_ctx->context_cap->is_texture_gen_r = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_GEN_R enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_S:

		{
			x86_opengl_ctx->context_cap->is_texture_gen_s = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_GEN_S enabled!\n");
			break;
		}

	case GL_TEXTURE_GEN_T:

		{
			x86_opengl_ctx->context_cap->is_texture_gen_t = GL_TRUE;
			x86_opengl_debug("\tGL_TEXTURE_GEN_T enabled!\n");
			break;
		}

	case GL_VERTEX_PROGRAM_POINT_SIZE:

		{
			x86_opengl_ctx->context_cap->is_vertex_program_point_size = GL_TRUE;
			x86_opengl_debug("\tGL_VERTEX_PROGRAM_POINT_SIZE enabled!\n");
			break;
		}

	case GL_VERTEX_PROGRAM_TWO_SIDE:

		{
			x86_opengl_ctx->context_cap->is_vertex_program_two_side = GL_TRUE;
			x86_opengl_debug("\tGL_VERTEX_PROGRAM_TWO_SIDE enabled!\n");
			break;
		}

	default:
		break;
	}

	/* Return success */
	return 0;
}

/*
 * OpenGL call #4 - glViewport
 *
 * glViewport - set the viewport
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glViewport(void)
{
	/* Variables */
	unsigned int vpt_ptr;

	/* Read arguments */
	vpt_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tvpt_ptr=0x%x\n", vpt_ptr);

	mem_read(x86_isa_mem, vpt_ptr, sizeof(struct x86_opengl_viewport_attributes_t), x86_opengl_ctx->viewport);

	/* Initialize */
	x86_opengl_debug("\tviewport: x=%d, y=%d, width=%d, height=%d\n",
				x86_opengl_ctx->viewport->x, x86_opengl_ctx->viewport->y, 
				x86_opengl_ctx->viewport->width, x86_opengl_ctx->viewport->height );

	/* Return */
	return 0;	
}

/*
 * OpenGL call #5 - glMatrixMode
 *
 * glMatrixMode - specify which matrix is the current matrix
 *
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glMatrixMode(void)
{
	/* Variables */
	unsigned int mtx_mode_ptr;

	/* Read arguments */
	mtx_mode_ptr = x86_isa_regs->ecx;
	x86_opengl_debug("\tmtx_mode_ptr=0x%x\n", mtx_mode_ptr);

	GLenum mtx_mod;
	mem_read(x86_isa_mem, mtx_mode_ptr, sizeof(mtx_mod), &mtx_mod);

	/* Set up current matrix */
	switch(mtx_mod)
	{
		case	GL_MODELVIEW:
		{
			x86_opengl_ctx->current_matrix_stack = x86_opengl_ctx->modelview_matrix_stack;
			break;
		}
			
		case	GL_PROJECTION:
		{
			x86_opengl_ctx->current_matrix_stack = x86_opengl_ctx->projection_matrix_stack;
			break;
		}

		case	GL_TEXTURE:
		{
			/* FIXME: choose which one? */
			x86_opengl_ctx->current_matrix_stack = x86_opengl_ctx->texture_matrix_stack[0];
			break;
		}

		case	GL_COLOR:
		{
			x86_opengl_ctx->current_matrix_stack = x86_opengl_ctx->color_matrix_stack;
			break;
		}
		default:
			break;
	}

	/* Return */
	return 0;	
}

/*
 * OpenGL call #6 - glLoadIdentity
 *
 * glLoadIdentity - replace the current matrix with the identity matrix
 *		       the current matrix in any mode is the matrix on the top of the stack for that mode.
 * @return
 *	The function always returns 0
 */

static int x86_opengl_func_glLoadIdentity(void)
{
	/* Pop from current stack and free the matrix */
	x86_opengl_matrix_stack_pop_and_free(x86_opengl_ctx->current_matrix_stack);

	/* Push identity matrix to the current matrix stack */
	struct x86_opengl_matrix_t *mtx = x86_opengl_matrix_create(MATRIX_IDENTITY);
	x86_opengl_matrix_stack_push(x86_opengl_ctx->current_matrix_stack, mtx);

	/* Return */
	return 0;	
}
