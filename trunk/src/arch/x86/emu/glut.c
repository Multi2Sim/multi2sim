/*
 *  Multi2Sim
 *  Copyright (C) 2011  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <x86-emu.h>
#include <mem-system.h>

static char *err_x86_glut_code =
	"\tAn invalid function code was generated by your application in a GLUT system\n"
	"\tcall. Probably, this means that your application is using an incompatible\n"
	"\tversion of the Multi2Sim GLUT runtime library ('libm2s-glut'). Please\n"
	"\trecompile your application and try again.\n";


/* Debug */
int x86_glut_debug_category;


/* List of GLUT runtime calls */
enum x86_glut_call_t
{
	x86_glut_call_invalid = 0,
#define X86_GLUT_DEFINE_CALL(name, code) x86_glut_call_##name = code,
#include "glut.dat"
#undef X86_GLUT_DEFINE_CALL
	x86_glut_call_count
};


/* List of GLUT runtime call names */
char *x86_glut_call_name[x86_glut_call_count + 1] =
{
	NULL,
#define X86_GLUT_DEFINE_CALL(name, code) #name,
#include "glut.dat"
#undef X86_GLUT_DEFINE_CALL
	NULL
};


/* Forward declarations of GLUT runtime functions */
#define X86_GLUT_DEFINE_CALL(name, code) static int x86_glut_func_##name(void);
#include "glut.dat"
#undef X86_GLUT_DEFINE_CALL


/* List of GLUT runtime functions */
typedef int (*x86_glut_func_t)(void);
static x86_glut_func_t x86_glut_func_table[x86_glut_call_count + 1] =
{
	NULL,
#define X86_GLUT_DEFINE_CALL(name, code) x86_glut_func_##name,
#include "glut.dat"
#undef X86_GLUT_DEFINE_CALL
	NULL
};


void x86_glut_init(void)
{
}


void x86_glut_done(void)
{
}


int x86_glut_call(void)
{
	int code;
	int ret;

	/* Function code */
	code = x86_isa_regs->ebx;
	if (code <= x86_glut_call_invalid || code >= x86_glut_call_count)
		fatal("%s: invalid GLUT function (code %d).\n%s",
			__FUNCTION__, code, err_x86_glut_code);

	/* Debug */
	x86_glut_debug("GLUT runtime call '%s' (code %d)\n",
		x86_glut_call_name[code], code);

	/* Call GLUT function */
	assert(x86_glut_func_table[code]);
	ret = x86_glut_func_table[code]();

	/* Return value */
	return ret;
}




/*
 * GLUT call #1 - init
 *
 * @param struct x86_glut_version_t *version;
 *	Structure where the version of the GLUT runtime implementation will be
 *	dumped. To succeed, the major version should match in the runtime
 *	library (guest) and runtime implementation (host), whereas the minor
 *	version should be equal or higher in the implementation (host).
 *
 *	Features should be added to the GLUT runtime (guest and host) using the
 *	following rules:
 *	1)  If the guest library requires a new feature from the host
 *	    implementation, the feature is added to the host, and the minor
 *	    version is updated to the current Multi2Sim SVN revision both in
 *	    host and guest.
 *          All previous services provided by the host should remain available
 *          and backward-compatible. Executing a newer library on the older
 *          simulator will fail, but an older library on the newer simulator
 *          will succeed.
 *      2)  If a new feature is added that affects older services of the host
 *          implementation breaking backward compatibility, the major version is
 *          increased by 1 in the host and guest code.
 *          Executing a library with a different (lower or higher) major version
 *          than the host implementation will fail.
 *
 * @return
 *	The runtime implementation version is return in argument 'version'.
 *	The return value is always 0.
 */

#define X86_GLUT_RUNTIME_VERSION_MAJOR	0
#define X86_GLUT_RUNTIME_VERSION_MINOR	680

struct x86_glut_version_t
{
	int major;
	int minor;
};

static int x86_glut_func_init(void)
{
	unsigned int version_ptr;

	struct x86_glut_version_t version;

	/* Arguments */
	version_ptr = x86_isa_regs->ecx;
	x86_glut_debug("\tversion_ptr=0x%x\n", version_ptr);

	/* Return version */
	assert(sizeof(struct x86_glut_version_t) == 8);
	version.major = X86_GLUT_RUNTIME_VERSION_MAJOR;
	version.minor = X86_GLUT_RUNTIME_VERSION_MINOR;
	mem_write(x86_isa_mem, version_ptr, sizeof version, &version);
	x86_glut_debug("\tGLUT Runtime host implementation v. %d.%d\n", version.major, version.minor);

	/* Return success */
	return 0;
}




/*
 * GLUT call #2 - get_event
 *
 * The function returns the next available GLUT event.
 *
 * @param struct x86_glut_event_t *event
 *	Pointer to a GLUT event structure where the next available event is
 *	written. If there is no new event, an event of type
 *	'x86_glut_event_idle' is returned.
 *
 * @return
 *	The return value is always 0.
 */

enum x86_glut_event_type_t
{
	x86_glut_event_invalid = 0,
	x86_glut_event_display,
	x86_glut_event_overlay_display,
	x86_glut_event_reshape,
	x86_glut_event_keyboard,
	x86_glut_event_mouse,
	x86_glut_event_motion,
	x86_glut_event_passive_motion,
	x86_glut_event_visibility,
	x86_glut_event_entry,
	x86_glut_event_special,
	x86_glut_event_spaceball_motion,
	x86_glut_event_spaceball_rotate,
	x86_glut_event_spaceball_button,
	x86_glut_event_button_box,
	x86_glut_event_dials,
	x86_glut_event_tablet_motion,
	x86_glut_event_tablet_button,
	x86_glut_event_menu_status,
	x86_glut_event_idle,
	x86_glut_event_timer
};

struct x86_glut_event_t
{
	enum x86_glut_event_type_t type;

	union
	{
		struct
		{
			int win;
		} display;

		struct
		{
			int win;
			int width;
			int height;
		} reshape;

		struct
		{
			int win;
		} overlay_display;

		struct
		{
			int win;
			unsigned char key;
			int x;
			int y;
		} keyboard;

		struct
		{
			int win;
			int button;
			int state;
			int x;
			int y;
		} mouse;

		struct
		{
			int win;
			int x;
			int y;
		} motion;

		struct
		{
			int win;
			int state;
		} visibility;

		struct
		{
			int win;
			int state;
		} entry;

		struct
		{
			int win;
			int key;
			int x;
			int y;
		} special;

		struct
		{
			int win;
			int x;
			int y;
			int z;
		} spaceball_motion;

		struct
		{
			int win;
			int x;
			int y;
			int z;
		} spaceball_rotate;

		struct
		{
			int win;
			int button;
			int state;
		} spaceball_button;

		struct
		{
			int win;
			int button;
			int state;
		} button_box;

		struct
		{
			int win;
			int dial;
			int value;
		} dials;

		struct
		{
			int win;
			int x;
			int y;
		} tablet_motion;

		struct
		{
			int win;
			int button;
			int state;
			int x;
			int y;
		} tablet_button;

		struct
		{
			int status;
			int x;
			int y;
		} menu_status;

		struct
		{
			int value;
		} timer;
	} u;
};

static int x86_glut_func_get_event(void)
{
	struct x86_glut_event_t event;

	unsigned int event_ptr;

	/* Read arguments */
	event_ptr = x86_isa_regs->ecx;
	x86_glut_debug("\tevent_ptr=0x%x\n", event_ptr);

	/* Reset structure */
	memset(&event, 0, sizeof event);

	/* Return 'idle' event */
	event.type = x86_glut_event_idle;
	mem_write(x86_isa_mem, event_ptr, sizeof event, &event);

	/* Return success */
	return 0;
}

