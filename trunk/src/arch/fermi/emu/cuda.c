/*
 *  Multi2Sim
 *  Copyright (C) 2011  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <fermi-emu.h>
#include <mem-system.h>
#include <x86-emu.h>

#include <time.h>



/*
 * Macros
 */

#define cuda_debug(stream, ...) ((!strcmp(getenv("LIBM2S_CUDA_DUMP"), "1")) ? \
	fprintf((stream), __VA_ARGS__) : (void) 0)



/*
 * Error Messages
 */

static char *err_frm_cuda_code =
	"\tAn invalid function code was generated by your application in a CUDA system\n"
	"\tcall. Probably, this means that your application is using an incompatible\n"
	"\tversion of the Multi2Sim CUDA driver library ('libm2s-cuda'). Please\n"
	"\trecompile your application and try again.\n";

//static char *err_frm_cuda_param_note =
//	"\tNote that a real CUDA implementation would return an error code to the\n"
//	"\tcalling program. However, the purpose of this CUDA implementation is to\n"
//	"\tsupport correctly written programs. Thus, a detailed implementation of CUDA\n"
//	"\terror handling is not provided, and any CUDA error will cause the\n"
//	"\tsimulation to stop.\n";



/*
 * CUDA Driver API Implementation
 */

/* List of CUDA driver calls */
enum frm_cuda_call_t
{
	frm_cuda_call_invalid = 0,
#define FRM_CUDA_DEFINE_CALL(name, code) frm_cuda_call_##name = code,
#include "cuda.dat"
#undef FRM_CUDA_DEFINE_CALL
	frm_cuda_call_count
};

/* List of CUDA driver call names */
char *frm_cuda_call_name[frm_cuda_call_count + 1] =
{
	NULL,
#define FRM_CUDA_DEFINE_CALL(name, code) #name,
#include "cuda.dat"
#undef FRM_CUDA_DEFINE_CALL
	NULL
};

/* Forward declarations of CUDA driver functions */
#define FRM_CUDA_DEFINE_CALL(name, code) static int frm_cuda_func_##name(void);
#include "cuda.dat"
#undef FRM_CUDA_DEFINE_CALL

/* List of CUDA driver functions */
typedef int (*frm_cuda_func_t)(void);
static frm_cuda_func_t frm_cuda_func_table[frm_cuda_call_count + 1] =
{
	NULL,
#define FRM_CUDA_DEFINE_CALL(name, code) frm_cuda_func_##name,
#include "cuda.dat"
#undef FRM_CUDA_DEFINE_CALL
	NULL
};



/*
 * CUDA global functions
 */

int frm_cuda_call(void)
{
	int code;
	int ret;

	/* Function code */
	code = x86_isa_regs->ebx;
	if (code <= frm_cuda_call_invalid || code >= frm_cuda_call_count)
		fatal("%s: invalid CUDA function (code %d).\n%s",
			__FUNCTION__, code, err_frm_cuda_code);

	/* Debug */
	cuda_debug(stdout, "CUDA call '%s' (code %d)\n",
		frm_cuda_call_name[code], code);

	/* Call CUDA function */
	assert(frm_cuda_func_table[code]);
	ret = frm_cuda_func_table[code]();

	/* Return value */
	return ret;
}



/*
 * CUDA call #1 - version
 *
 * @param struct frm_cuda_version_t *version;
 *	Structure where the version of the CUDA runtime implementation will be
 *	dumped. To succeed, the major version should match in the runtime
 *	library (guest) and runtime implementation (host), whereas the minor
 *	version should be equal or higher in the implementation (host).
 *
 *	Features should be added to the CUDA runtime (guest and host) using the
 *	following rules:
 *	1)  If the guest library requires a new feature from the host
 *	    implementation, the feature is added to the host, and the minor
 *	    version is updated to the current Multi2Sim SVN revision both in
 *	    host and guest.
 *          All previous services provided by the host should remain available
 *          and backward-compatible. Executing a newer library on the older
 *          simulator will fail, but an older library on the newer simulator
 *          will succeed.
 *      2)  If a new feature is added that affects older services of the host
 *          implementation breaking backward compatibility, the major version is
 *          increased by 1 in the host and guest code.
 *          Executing a library with a different (lower or higher) major version
 *          than the host implementation will fail.
 *
 * @return
 *	The runtime implementation version is return in argument 'version'.
 *	The return value is always 0.
 */

#define FRM_CUDA_VERSION_MAJOR	1
#define FRM_CUDA_VERSION_MINOR	700

struct frm_cuda_version_t
{
	int major;
	int minor;
};

static int frm_cuda_func_version(void)
{
	struct frm_cuda_version_t version;

	version.major = FRM_CUDA_VERSION_MAJOR;
	version.minor = FRM_CUDA_VERSION_MINOR;

	cuda_debug(stdout, "\tversion.major=%d\n", version.major);
	cuda_debug(stdout, "\tversion.minor=%d\n", version.minor);

	mem_write(x86_isa_mem, x86_isa_regs->ecx, sizeof version, &version);

	return 0;
}

static int frm_cuda_func_cuCtxCreate(void)
{
	unsigned int args[2];
	unsigned int pctx;
	unsigned int dev;
	struct frm_cuda_context_t *context;

        mem_read(x86_isa_mem, x86_isa_regs->ecx, 2*sizeof(unsigned int), args);
	pctx = args[0];
	dev = args[1];

	/* Create context */
	context = frm_cuda_context_create();
        context->device_id = dev;
        mem_write(x86_isa_mem, pctx, sizeof(unsigned int), &context->id);

	return 0;
}

static int frm_cuda_func_cuModuleLoad(void)
{
	unsigned int args[2];
	unsigned int pmod;
	char file_name[MAX_STRING_SIZE];
	struct frm_cuda_module_t *module;

        mem_read(x86_isa_mem, x86_isa_regs->ecx, 2*sizeof(unsigned int), args);
        pmod = args[0];
	cuda_debug(stdout, "\tpmod=%#8x\n", pmod);
        mem_read(x86_isa_mem, args[1], sizeof(file_name), file_name);
	cuda_debug(stdout, "\tfile_name=%s\n", file_name);

        module = frm_cuda_module_create();
	module->elf_file = elf_file_create_from_path(file_name);
        mem_write(x86_isa_mem, pmod, sizeof(unsigned int), &module->id);

	return 0;
}

static int frm_cuda_func_cuModuleGetFunction(void)
{
	unsigned int args[3];
	unsigned int pfunc;
	unsigned int mod_id;
	char function_name[MAX_STRING_SIZE];
	struct frm_cuda_module_t *module;
	struct frm_cuda_function_t *function;

        mem_read(x86_isa_mem, x86_isa_regs->ecx, 3*sizeof(unsigned int), args);
	pfunc = args[0];
        mem_read(x86_isa_mem, args[1], sizeof(unsigned int), &mod_id);
        mem_read(x86_isa_mem, args[2], sizeof(function_name), function_name);

	cuda_debug(stdout, "\tfunction_name=%s\n", function_name);

        /* Get module */
        module = frm_cuda_object_get(FRM_CUDA_OBJ_MODULE, mod_id);

        /* Create function */
        function = frm_cuda_function_create();
	function->module_id = module->id;

        /* Load function */
//        evg_opencl_kernel_load(kernel, kernel_name_str);

        mem_write(x86_isa_mem, pfunc, sizeof(unsigned int), &function->id);

	return 0;
}

static int frm_cuda_func_cuLaunchKernel(void)
{
	unsigned int args[11];
        unsigned int f;
        unsigned int gridDimX;
        unsigned int gridDimY;
        unsigned int gridDimZ;
        unsigned int blockDimX;
        unsigned int blockDimY;
        unsigned int blockDimZ;
        unsigned int sharedMemBytes;
        unsigned int hStream;
        unsigned int kernelParams;
        unsigned int extra;
	//struct frm_cuda_kernel_t *kernel;

        mem_read(x86_isa_mem, x86_isa_regs->ecx, 11*sizeof(unsigned int), args);
	f = args[0];
        gridDimX = args[1];
        gridDimY = args[2];
        gridDimZ = args[3];
        blockDimX = args[4];
        blockDimY = args[5];
        blockDimZ = args[6];
        sharedMemBytes = args[7];
        hStream = args[8];
        kernelParams = args[9];
        extra = args[10];

	cuda_debug(stdout, "\tf=%u\n", f);
	cuda_debug(stdout, "\tgridDimX=%u\n", gridDimX);
	cuda_debug(stdout, "\tgridDimY=%u\n", gridDimY);
	cuda_debug(stdout, "\tgridDimZ=%u\n", gridDimZ);
	cuda_debug(stdout, "\tblockDimX=%u\n", blockDimX);
	cuda_debug(stdout, "\tblockDimY=%u\n", blockDimY);
	cuda_debug(stdout, "\tblockDimZ=%u\n", blockDimZ);
	cuda_debug(stdout, "\tsharedMemBytes=%u\n", sharedMemBytes);
	cuda_debug(stdout, "\thStream=%u\n", hStream);
	cuda_debug(stdout, "\tkernelParams=%u\n", kernelParams);
	cuda_debug(stdout, "\textra=%u\n", extra);

//	kernel = frm_cuda_object_get(FRM_CUDA_OBJ_KERNEL, f);
//	kernel->work_dim = 1;

//	frm_grid_run(kernel->grid);

//	frm_grid_free(kernel->grid);

	return 0;
}

