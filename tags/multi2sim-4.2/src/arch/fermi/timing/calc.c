/*
 *  Multi2Sim
 *  Copyright (C) 2012  Rafael Ubal (ubal@ece.neu.edu)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <unistd.h>

#include <arch/fermi/emu/emu.h>
#include <arch/fermi/emu/grid.h>
#include <lib/util/debug.h>
#include <lib/util/file.h>
#include <lib/util/misc.h>

#include "calc.h"
#include "gpu.h"


char *frm_gpu_calc_file_name = "";

static char *err_gnuplot_msg =
	"\nThe execution of the 'gnuplot' command-line failed. Please check "
	"that this\n"
	"\tapplication is installed on your system. An error message "
	"could have occurred\n"
	"\tas well if gnuplot commands generated by Multi2Sim are not "
	"supported in the\n"
	"\tgnuplot version currently installed.\n";




int frm_calc_get_thread_blocks_per_sm(int threads_per_thread_block,
	int registers_per_thread, int shared_mem_per_thread_block)
{
	int warps_per_thread_block;
	int registers_per_thread_block;
	int max_thread_blocks_limitted_by_max_warps;
	int max_thread_blocks_limitted_by_num_registers;
	int max_thread_blocks_limitted_by_shared_mem;
	int max_thread_blocks_per_sm;

	/* Get maximum number of thread blocks per SM as limited by the 
	 * maximum number of warps, given the number of warps per 
	 * thread block in the grid */
	assert(frm_emu_warp_size > 0);
	warps_per_thread_block = (threads_per_thread_block + 
		frm_emu_warp_size - 1) / frm_emu_warp_size;
	max_thread_blocks_limitted_by_max_warps = 
		frm_gpu_max_warps_per_sm / warps_per_thread_block;

	/* Get maximum number of thread blocks per SM as limited by the number 
	 * of available registers, given the number of registers used per 
	 * thread. */
	registers_per_thread_block = registers_per_thread *
		threads_per_thread_block;
	max_thread_blocks_limitted_by_num_registers = registers_per_thread_block ?
		frm_gpu_num_registers_per_sm / registers_per_thread_block :
		frm_gpu_max_thread_blocks_per_sm;

	/* Get maximum number of thread blocks per SM as limited by the 
	 * amount of available shared memory, given the shared memory used 
	 * per thread block in the grid */
	max_thread_blocks_limitted_by_shared_mem = shared_mem_per_thread_block ?
		frm_gpu_shared_mem_size / shared_mem_per_thread_block :
		frm_gpu_max_thread_blocks_per_sm;

	/* Based on the limits above, calculate the actual limit of thread
	 * blocks per SM. */
	max_thread_blocks_per_sm = frm_gpu_max_thread_blocks_per_sm;
	max_thread_blocks_per_sm = MIN(max_thread_blocks_per_sm,
		max_thread_blocks_limitted_by_max_warps);
	max_thread_blocks_per_sm = MIN(max_thread_blocks_per_sm, 
		max_thread_blocks_limitted_by_num_registers);
	max_thread_blocks_per_sm = MIN(max_thread_blocks_per_sm, 
		max_thread_blocks_limitted_by_shared_mem);

	/* Return */
	return max_thread_blocks_per_sm;
}

static void frm_calc_plot_threads_per_thread_block(void)
{
	FILE *data_file, *script_file;

	char plot_file_name[MAX_PATH_SIZE];
	char data_file_name[MAX_PATH_SIZE];
	char script_file_name[MAX_PATH_SIZE];
	char cmd[MAX_PATH_SIZE];
	
	//int local_mem_per_thread_block;
	int threads_per_thread_block;
	//int registers_per_thread;

	int warps_per_thread_block;
	int thread_blocks_per_warp_pool = 1;
	int warps_per_warp_pool;

	int err;

	/* Create plot file */
	snprintf(plot_file_name, MAX_PATH_SIZE, "%s.%d.threads.eps",
		frm_gpu_calc_file_name, frm_gpu->grid->id);
	if (!file_can_open_for_write(plot_file_name))
	{
		fatal("%s: cannot write GPU occupancy calculation plot", 
			plot_file_name);
	}

	/* Generate data file */
	data_file = file_create_temp(data_file_name, MAX_PATH_SIZE);
	//local_mem_per_thread_block = frm_gpu->grid->local_mem_top;
	//registers_per_thread = 
	//	frm_gpu->grid->num_gpr_used;
	for (threads_per_thread_block = frm_emu_warp_size;
		threads_per_thread_block < 
		(frm_gpu_max_warps_per_sm * 
		frm_emu_warp_size);
		threads_per_thread_block += frm_emu_warp_size)
	{
		/* Calculate point */
		//thread_blocks_per_warp_pool = 
		//	frm_calc_get_thread_blocks_per_warp_pool(
		//		threads_per_thread_block, 
		//		registers_per_thread, 
		//		local_mem_per_thread_block);
		warps_per_thread_block = (threads_per_thread_block + 
			frm_emu_warp_size - 1) / frm_emu_warp_size;
		warps_per_warp_pool = thread_blocks_per_warp_pool *
			warps_per_thread_block;

		/* Dump line to data file */
		fprintf(data_file, "%d %d\n", threads_per_thread_block, 
				warps_per_warp_pool);
	}
	fclose(data_file);

	/* Current data point */
	threads_per_thread_block = ROUND_UP(
		frm_gpu->grid->block_size, 
		frm_emu_warp_size);
	//thread_blocks_per_warp_pool = 
	//	frm_calc_get_thread_blocks_per_warp_pool(
	//		threads_per_thread_block, registers_per_thread, 
	//		local_mem_per_thread_block);
	warps_per_thread_block = (threads_per_thread_block + 
		frm_emu_warp_size - 1) / frm_emu_warp_size;
	warps_per_warp_pool = thread_blocks_per_warp_pool * 
		warps_per_thread_block;

	/* Generate gnuplot script */
	script_file = file_create_temp(script_file_name, MAX_PATH_SIZE);
	fprintf(script_file, "set term postscript eps color solid\n");
	fprintf(script_file, "set nokey\n");
	fprintf(script_file, "set xlabel 'Work-items per work-group'\n");
	fprintf(script_file, "set ylabel 'Wavefronts per SIMD'\n");
	fprintf(script_file, "set size 0.65, 0.5\n");
	fprintf(script_file, "set grid ytics\n");
	fprintf(script_file, "plot '%s' w linespoints lt 3 lw 5 pt 84 ps 2, ", 
		data_file_name);
	fprintf(script_file, "'-' w linespoints lt 1 lw 4 pt 82 ps 2\n%d "
		"%d\ne\n", threads_per_thread_block, 
		warps_per_warp_pool);
	fclose(script_file);

	/* Plot */
	sprintf(cmd, "gnuplot %s > %s", script_file_name, plot_file_name);
	err = system(cmd);
	if (err)
		warning("could not execute gnuplot\n%s", err_gnuplot_msg);

	/* Remove temporary files */
	unlink(data_file_name);
	unlink(script_file_name);
}


static void frm_calc_plot_registers_per_thread(void)
{
	FILE *data_file, *script_file;

	char plot_file_name[MAX_PATH_SIZE];
	char data_file_name[MAX_PATH_SIZE];
	char script_file_name[MAX_PATH_SIZE];
	char cmd[MAX_PATH_SIZE];
	
	//int local_mem_per_thread_block;
	int threads_per_thread_block;
	int registers_per_thread;

	int warps_per_thread_block;
	int thread_blocks_per_warp_pool = 1;
	int warps_per_warp_pool;

	int err;

	/* Create plot file */
	snprintf(plot_file_name, MAX_PATH_SIZE, "%s.%d.registers.eps",
		frm_gpu_calc_file_name, frm_gpu->grid->id);
	if (!file_can_open_for_write(plot_file_name))
	{
		fatal("%s: cannot write GPU occupancy calculation plot", 
			plot_file_name);
	}

	/* Generate data file */
	data_file = file_create_temp(data_file_name, MAX_PATH_SIZE);
	//local_mem_per_thread_block = frm_gpu->grid->local_mem_top;
	threads_per_thread_block = frm_gpu->grid->block_size;
	warps_per_thread_block = (threads_per_thread_block + 
		frm_emu_warp_size - 1) / frm_emu_warp_size;
	for (registers_per_thread = 1; registers_per_thread <= 128; 
		registers_per_thread += 4)
	{
		/* Calculate point */
		//thread_blocks_per_warp_pool = 
		//	frm_calc_get_thread_blocks_per_warp_pool(
		//		threads_per_thread_block, 
		//		registers_per_thread, 
		//		local_mem_per_thread_block);
		warps_per_warp_pool = thread_blocks_per_warp_pool *
			warps_per_thread_block;

		/* Dump line to data file */
		fprintf(data_file, "%d %d\n", registers_per_thread, 
			warps_per_warp_pool);
	}
	fclose(data_file);

	/* Current data point */
	registers_per_thread = frm_gpu->grid->num_gpr_used;
	//thread_blocks_per_warp_pool = 
	//	frm_calc_get_thread_blocks_per_warp_pool(
	//		threads_per_thread_block, 
	//		registers_per_thread, local_mem_per_thread_block);
	warps_per_warp_pool = thread_blocks_per_warp_pool * 
		warps_per_thread_block;

	/* Generate gnuplot script */
	script_file = file_create_temp(script_file_name, MAX_PATH_SIZE);
	fprintf(script_file, "set term postscript eps color solid\n");
	fprintf(script_file, "set nokey\n");
	fprintf(script_file, "set xlabel 'Registers per work-item'\n");
	fprintf(script_file, "set ylabel 'Wavefronts per SIMD'\n");
	fprintf(script_file, "set xrange [0:128]\n");
	fprintf(script_file, "set yrange [0:]\n");
	fprintf(script_file, "set xtics (0,16,32,48,64,80,96,112,128)\n");
	fprintf(script_file, "set size 0.65, 0.5\n");
	fprintf(script_file, "set grid ytics\n");
	fprintf(script_file, "plot '%s' w linespoints lt 3 lw 5 pt 84 ps 2, ", 
		data_file_name);
	fprintf(script_file, "'-' w linespoints lt 1 lw 4 pt 82 ps 2\n%d "
		"%d\ne\n", registers_per_thread, 
		warps_per_warp_pool);
	fclose(script_file);

	/* Plot */
	sprintf(cmd, "gnuplot %s > %s", script_file_name, plot_file_name);
	err = system(cmd);
	if (err)
		warning("could not execute gnuplot\n%s", err_gnuplot_msg);

	/* Remove temporary files */
	unlink(data_file_name);
	unlink(script_file_name);
}


static void frm_calc_plot_local_mem_per_thread_block(void)
{
	FILE *data_file, *script_file;

	char plot_file_name[MAX_PATH_SIZE];
	char data_file_name[MAX_PATH_SIZE];
	char script_file_name[MAX_PATH_SIZE];
	char cmd[MAX_PATH_SIZE];
	
	int local_mem_per_thread_block;
	int threads_per_thread_block;
	//int registers_per_thread;

	int warps_per_thread_block;
	int thread_blocks_per_warp_pool = 1;
	int warps_per_warp_pool;
	int local_mem_step;

	int err;

	/* Create plot file */
	snprintf(plot_file_name, MAX_PATH_SIZE, "%s.%d.local_mem.eps",
		frm_gpu_calc_file_name, frm_gpu->grid->id);
	if (!file_can_open_for_write(plot_file_name))
		fatal("%s: cannot write GPU occupancy calculation plot", 
			plot_file_name);

	/* Generate data file */
	data_file = file_create_temp(data_file_name, MAX_PATH_SIZE);
	//registers_per_thread = frm_gpu->grid->num_gpr_used;
	local_mem_step = MAX(1, frm_gpu_shared_mem_size / 32);
	threads_per_thread_block = frm_gpu->grid->block_size;
	warps_per_thread_block = (threads_per_thread_block + 
		frm_emu_warp_size - 1) / frm_emu_warp_size;
	for (local_mem_per_thread_block = local_mem_step;
		local_mem_per_thread_block <= frm_gpu_shared_mem_size;
		local_mem_per_thread_block += local_mem_step)
	{
		/* Calculate point */
		//thread_blocks_per_warp_pool = 
		//	frm_calc_get_thread_blocks_per_warp_pool(
		//	threads_per_thread_block, registers_per_thread, 
		//	local_mem_per_thread_block);
		warps_per_warp_pool = thread_blocks_per_warp_pool *
			warps_per_thread_block;

		/* Dump line to data file */
		fprintf(data_file, "%d %d\n", local_mem_per_thread_block, 
			warps_per_warp_pool);
	}
	fclose(data_file);

	/* Current data point */
	local_mem_per_thread_block = frm_gpu->grid->local_mem_top;
	//thread_blocks_per_warp_pool = 
	//	frm_calc_get_thread_blocks_per_warp_pool(
	//		threads_per_thread_block, registers_per_thread, 
	//		local_mem_per_thread_block);
	warps_per_warp_pool = thread_blocks_per_warp_pool * 
		warps_per_thread_block;

	/* Generate gnuplot script */
	script_file = file_create_temp(script_file_name, MAX_PATH_SIZE);
	fprintf(script_file, "set term postscript eps color solid\n");
	fprintf(script_file, "set nokey\n");
	fprintf(script_file, "set xlabel 'Local memory used per work-group "
		"(KB)'\n");
	fprintf(script_file, "set ylabel 'Wavefronts per SIMD'\n");
	fprintf(script_file, "set xrange [0:%d]\n", frm_gpu_shared_mem_size / 1024);
	fprintf(script_file, "set yrange [0:]\n");
	fprintf(script_file, "set size 0.65, 0.5\n");
	fprintf(script_file, "set grid ytics\n");
	fprintf(script_file, "plot '%s' u ($1/1024):2 w linespoints lt 3 "
		"lw 5 pt 84 ps 2, ", data_file_name);
	fprintf(script_file, "'-' u ($1/1024):2 w linespoints lt 1 lw 4 pt 82 "
		"ps 2\n%d %d\ne\n", local_mem_per_thread_block, 
		warps_per_warp_pool);
	fclose(script_file);

	/* Plot */
	sprintf(cmd, "gnuplot %s > %s", script_file_name, plot_file_name);
	err = system(cmd);
	if (err)
		warning("could not execute gnuplot\n%s", err_gnuplot_msg);

	/* Remove temporary files */
	unlink(data_file_name);
	unlink(script_file_name);
}


void frm_calc_plot(void)
{
	int ret;

	/* If no file specified for plots, done */
	if (!*frm_gpu_calc_file_name)
		return;

	/* Find 'gnuplot' */
	ret = system("which gnuplot >/dev/null 2>&1");
	if (ret)
	{
		fatal("GPU occupancy calculation plots could not be "
			"generated.\n"
			"\tThe tool 'gnuplot' is required to generate GPU "
			"occupancy plots. Please\n"
			"\tmake sure that it is installed on your system and "
			"retry.\n");
	}

	/* Plot varying work-items per work-group */
	frm_calc_plot_threads_per_thread_block();

	/* Plot varying registers per work-item */
	frm_calc_plot_registers_per_thread();

	/* Plot varying local memory per work-group */
	frm_calc_plot_local_mem_per_thread_block();
}

