version 0:96:$full:$small;

// Runtime definitions
function &hsa_init (arg_u32 %status) ();
function &hsa_stut_down (arg_u32 %status) ();
function &hsa_iterate_agents (arg_u32 %status) (arg_u32 %call_back, arg_u32 %data);
function &hsa_iterate_agent_next (arg_u32 %status) (arg_u32 %call_back, arg_u32 %data);
function &hsa_agent_get_info (arg_u32 %status) (arg_u64 %agent, arg_u32 %attribute, arg_u32 %value);

function &get_global_id(arg_u32 %ret_val) (arg_u32 %arg_val0);

// Iterate agent callback 
function &select_gpu_if_possible (arg_u32 %status) ( arg_u64 %agent, arg_u32 %data)
{
	// Load argument %agent into register %d1
	ld_arg_u64 $d1, [%agent];
	// Declare a local variable for storing the type of the device
	private_u32 %type;
	{
		// Declare a variable for function return
		arg_u32 %err;
		// Declear an argument for the attribute to retrieve
		arg_u32 %attribute;
		// Set the value of %attribute to be 13, for device type
		st_arg_u32 13, [%attribute];
		// Get the address of the variable %type;
		lda_private_u32 $s1, [%type];
		// Declare an argument to pass the address of the data field
		arg_u32 %type_addr;
		// Set the value of %type_addr
		st_arg_u32 $s1, [%type_addr];
		arg_u64 %agent_arg;
		st_arg_u64 $d1, [%agent_arg];
		call &hsa_agent_get_info (%err) (%agent_arg, %attribute, %type_addr);
	}
	
	ld_private_u32 $s0, [%type];

	// If the device is a GPU
	cmp_ne_b1_u32 $c0, $s0, 1;
	cbr $c0, @not_gpu_agent;
	ld_arg_u64 $d0, [%agent];
	ld_arg_u32 $s1, [%data];
	st_arg_u64 $d0, [$s1];
	st_arg_u32 0, [%status];
	ret;
	
@not_gpu_agent:
	cmp_eq_b1_u32 $c0, $s0, 0; 	// If CPU device
	cbr $c0, @not_cpu_agent;
	ld_arg_u32 $s1, [%data];
	ld_arg_u64 $d0, [$s1];
	cmp_eq_b1_u64 $c0, $d0, 0;
	cbr $c0, @add_this_cpu;
	st_arg_u32 0, [%status];
	ret;

@add_this_cpu:
	ld_arg_u64 $d0, [%agent];
	ld_arg_u32 $s1, [%data];
	st_arg_u64 $d0, [$s1];
	st_arg_u32 0, [%status];
	ret;
	
@not_cpu_agent:
	st_arg_u32 0, [%status];
	ret;
	
};


kernel &__OpenCL_vec_add_kernel(
  kernarg_u32 %arg_val0,
  kernarg_u32 %arg_val1,
  kernarg_u32 %arg_val2,
  kernarg_u32 %arg_val3)
{
@__OpenCL_vec_add_kernel_entry:
// BB#0:             // %entry
  ld_kernarg_u32 $s0, [%arg_val3];
  workitemabsid_u32 $s1, 0;
  cmp_lt_b1_u32     $c0, $s1, $s0;
  ld_kernarg_u32    $s0, [%arg_val2];
  ld_kernarg_u32    $s2, [%arg_val1];
  ld_kernarg_u32    $s3, [%arg_val0];
  cbr $c0, @BB0_2;
  brn @BB0_1;

@BB0_1:
  ret;    // %if. end
@BB0_2:
  shl_u32  $s1, $s1, 2;
  add_u32  $s2, $s2, $s1;
  ld_global_f32 $s2, [$s2];
  add_u32  $s3, $s3, $s1;
  ld_global_f32 $s3, [$s3];
  add_f32  $s2, $s3, $s2;
  add_u32  $s0, $s0, $s1;
  st_global_f32 $s2, [$s0];
  brn @BB0_1;
};

function &main()(){

	{
		arg_u32 %err;
		call &hsa_init (%err)();
	}
	
	private_u64 %device;
	{
		arg_u32 %err;
		lda_private_u32 $s0, [%device];
		arg_u32 %device_addr;
		st_arg_u32 $s0, [%device_addr];
		ldc_u32 $s0, &select_gpu_if_possible;
		arg_u32 %call_back;
		st_arg_u32 $s0, [%call_back];
		call &hsa_iterate_agents (%err) (%call_back, %device_addr);
	}
	
	ret;	

};
